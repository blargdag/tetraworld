Oh yes, still more detritus from 4D obsession.

Motivation:
- D's compile-time introspection makes it actually possible to write
  world-level objects as D classes! Isn't that awesome?!
- We can probably even auto-serialize using this trick too! No need for flaky
  fragile wrappers and hacked parse scripts to generate code from hand-made
  unreliable templates; just write straight D code and use introspection to
  auto-serialize stuff. Whoa! D just acquired whole new levels of cool!

//

Mapgen ideas:

- Tiered map generation:
   - First n levels of BSP tree can be used for generating large-scale
     topological features, such as disjoint regions connected by locked doors.
   - Middle levels of BSP can be used for thematic regions, like different
     terrain styles, vertically-oriented regions with largely climbing-related
     play styles, experience-oriented regions / mini-puzzles/challenges.
   - Lowest levels of BSP are individual rooms.

//

Language handling ideas:

- The obvious way to handle different noun forms, etc., is to represent all
  nouns by an abstract ID that gets looked up in a language-specific
  dictionary, yielding an object that encodes its various forms.
- This is cumbersome, though; since every new object will need modification in
  several files just to add a single word.
- What about using string literals as the dictionary key?
   - The key will by default always be English. But that does not preclude
     dictionaries that yield entries that translate the English noun into the
     target language.
      - If translations lag behind, the English word will be substituted as a
        placeholder until translators catch up. This will prevent the impasse
        in Elephant! where every language has to be updated with every form of
        every newly added word.
   - Furthermore, to alleviate the tedium and redundancy of defining every form
     of every noun, make it a rule that if a key is not found, then the code
     falls back to a default, language-specific declension pattern.
   - In fact, the noun definition can arbitarily omit any form if the default
     declension pattern derives the correct form. So you only have to
     explicitly define the exceptions to the rule, rather than every single
     word.
   - A more sophisticated system would be to have a tag in the noun definition
     to indicate things like declension class, so you could have multiple
     default declension that cover 90% of the cases, leaving only few
     exceptions to be explicitly coded for.


// vim:set sw=3 ts=3 et ai:
