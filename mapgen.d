/**
 * Map generation module.
 * ----------------------------------------------------------------------------
 * Map representation notes:
 *
 * Maps are represented using BSP trees (see bsp.d). The default map generators
 * use genBsp() to create a random BSP tree, subject to some constraints, but
 * it can be generated by any means you wish (see genTutorialLevel() for
 * example).  Rooms are assumed to occupy one leaf node (MapNode) each.
 *
 * Doors must be duplicated in *both* rooms that they connect. This doesn't
 * matter during map redition (leftmost doors do not get rendered), but it
 * *does* matter during map generation because, e.g., leftmost doors are
 * required to generate ladder objects, otherwise there would be no ladders
 * connecting to leftmost doors.
 *
 * The actual size of the room may differ from the BSP node's bounding region;
 * the .interior of the room represents the actual interior of the room (NOT
 * including any outer walls).
 *
 * Copyright: (C) 2012-2021  blargdag@quickfur.ath.cx
 *
 * This file is part of Tetraworld.
 *
 * Tetraworld is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free
 * Software Foundation, either version 2 of the License, or (at your option)
 * any later version.
 *
 * Tetraworld is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * Tetraworld.  If not, see <http://www.gnu.org/licenses/>.
 */
module mapgen;

import std.algorithm;
import std.math : abs;
import std.random : uniform;
import std.range;

import bsp;
import components;
import gamemap;
import rndutil;
import terrain;
import vector;
import world;

/**
 * Initialize room interiors to the maximum size per BSP node, minus a 1-tile
 * space for the inter-room walls.
 */
void setRoomInteriors(MapNode root, Region!(int,4) bounds)
{
    foreachRoom(root, bounds, (Region!(int,4) r, MapNode node) {
        node.interior = region(r.min, r.max - vec(1,1,1,1));
        return 0;
    });
}

unittest
{
    // Test case 1:
    //   0123456789
    // 0 ##########
    // 1 #   #    #
    // 2 #   #    #
    // 3 #####    #
    // 4 #   #    #
    // 5 #   #    #
    // 6 ##########
    auto root = new MapNode;
    root.axis = 2;
    root.pivot = 5;

    root.left = new MapNode;
    root.left.axis = 3;
    root.left.pivot = 4;
    root.left.left = new MapNode;
    root.left.right = new MapNode;

    root.right = new MapNode;

    auto bounds = region(vec(0,0,1,1), vec(2,2,10,7));
    setRoomInteriors(root, bounds);

    assert(root.left.left.interior == region(vec(0,0,1,1), vec(1,1,4,3)));
    assert(root.left.right.interior == region(vec(0,0,1,4), vec(1,1,4,6)));
    assert(root.right.interior == region(vec(0,0,5,1), vec(1,1,9,6)));
}

/**
 * Returns: The total interior volumes of the rooms in the given BSP tree.
 *
 * BUGS: This function is either misnamed, or wrongly implemented. It returns
 * the total interior *volume* of the map, not its *floor* area!
 */
int floorArea(MapNode node)
{
    if (node.isLeaf)
        return iota(1, 4)
            .map!(i => node.interior.max[i] - node.interior.min[i])
            .fold!((a, b) => a*b)(1);
    else
        return floorArea(node.left) + floorArea(node.right);
}

unittest
{
    auto tree = new MapNode;
    tree.interior = region(vec(1,1,1,1), vec(3,3,3,3));
    assert(floorArea(tree) == 8);

    tree.interior = region(vec(1,1,1,1), vec(20,3,3,3));
    assert(floorArea(tree) == 8);

    tree.interior = region(vec(1,1,1,1), vec(20,4,3,3));
    assert(floorArea(tree) == 12);
}

private class GenCorridorsException : Exception
{
    this(string msg) { super(msg); }
}

/**
 * Prerequisities: The .interior of the node must have already been set.
 *
 * Returns: The filter region corresponding to the rightmost wall of the given
 * node along the given axis. (Note that it is not the *actual* rightmost wall,
 * since that lies inside the node bounds, whereas the wall filter lies 1 tile
 * past that in order to intersect with the adjacent room's bounds.)
 */
Region!(int,4) rightWallFilt(MapNode node, Region!(int,4) bounds, int axis)
{
    auto filt = node.interior;
    filt.min[axis] = filt.max[axis] = bounds.max[axis];
    return filt;
}

unittest
{
    auto node = new MapNode;
    auto bounds = region(vec(1,1,1,1), vec(5,5,5,5));
    setRoomInteriors(node, bounds);
    assert(rightWallFilt(node, bounds, 0) ==
           region(vec(5,1,1,1), vec(5,4,4,4)));
}

/**
 * Prerequisities: The .interior of the node must have already been set.
 *
 * Returns: The filter region corresponding to the leftmost wall of the given
 * node along the given axis. (Note that it is not the *actual* leftmost wall,
 * since that lies outside the node bounds, whereas the wall filter lies along
 * the first row of tiles in the room's interior in order to intersect with the
 * adjacent room's filter.)
 */
Region!(int,4) leftWallFilt(MapNode node, Region!(int,4) bounds, int axis)
{
    auto filt = node.interior;
    filt.min[axis] = filt.max[axis] = bounds.min[axis];
    return filt;
}

unittest
{
    auto node = new MapNode;
    auto bounds = region(vec(1,1,1,1), vec(5,5,5,5));
    setRoomInteriors(node, bounds);
    assert(leftWallFilt(node, bounds, 0) ==
           region(vec(1,1,1,1), vec(1,4,4,4)));
}

/**
 * Generate a random position corresponding to a door in the given intersection
 * of two wall filters.
 *
 * Returns: true if successful, false if a suitable position could not be
 * found.
 */
bool randomEdgePos(Region!(int,4) ir, int axis, out int[4] basePos)
    in (ir.min[axis] == ir.max[axis])
{
    foreach (i; 0 .. 4)
    {
        import std.random : uniform;
        if (i == axis)
        {
            assert(ir.min[i] == ir.max[i]);
            basePos[i] = ir.min[i] - 1;
        }
        else if (ir.max[i] - ir.min[i] > 0)
            basePos[i] = uniform(ir.min[i], ir.max[i]);
        else
        {
            // Overlap is too small to place a door, skip.
            return false;
        }
    }
    return true;
}

/**
 * Generate corridors based on BSP tree structure.
 *
 * Prerequisites: The .interior bounds of each leaf node must have already been
 * set, either by setRoomInteriors(), or some other means.
 *
 * Throws: GenCorridorsException if the given BSP tree does not allow doors to
 * be placed according to the BSP connectivity structure. This is pretty rare
 * but *does* happen (2-8% for a 64^4 map, seems rarer on smaller maps), so the
 * caller should catch this exception and rebuild with a different BSP tree
 * instead.
 */
void genCorridors(R)(MapNode root, R region)
    if (is(R == Region!(int,n), size_t n))
{
    if (root.isLeaf) return;

    genCorridors(root.left, leftRegion(region, root.axis, root.pivot));
    genCorridors(root.right, rightRegion(region, root.axis, root.pivot));

    static struct LeftRoom
    {
        MapNode node;
        R region;
    }

    LeftRoom[] leftRooms;
    root.left.foreachFiltRoom(leftRegion(region, root.axis, root.pivot),
        (R r) => r.max[root.axis] >= root.pivot,
        (MapNode node1, R r1) {
            leftRooms ~= LeftRoom(node1, r1);
            return 0;
        });

//import std;writefln("leftRooms=%s", leftRooms);
    int ntries=0;
    while (ntries++ < 2*leftRooms.length)
    {
        import rndutil : pickOne;
        auto leftRoom = leftRooms.pickOne;
        R wallFilt = rightWallFilt(leftRoom.node, leftRoom.region, root.axis);
//import std;writefln("wallFilt=%s", wallFilt);

        static struct RightRoom
        {
            MapNode node;
            R region;
            int[4] basePos;
        }

        RightRoom[] rightRooms;
        root.right.foreachFiltRoom(rightRegion(region, root.axis, root.pivot),
            wallFilt, (MapNode node2, R r2) {
                auto wallFilt2 = leftWallFilt(node2, r2, root.axis);
//import std;writefln("wallFilt2=%s", wallFilt2);
                auto ir = wallFilt.intersect(wallFilt2);
//import std;writefln("ir=%s", ir);

                int[4] basePos;
                if (!randomEdgePos(ir, root.axis, basePos))
                {
//import std.stdio;writefln("left=%s right=%s TOO NARROW, SKIPPING", leftRoom.region, r2);
                    return 0;
                }

//import std;writefln("basePos=%s", basePos);

                rightRooms ~= RightRoom(node2, r2, basePos);
                return 0;
            });

        // If can't find a suitable door placement, try picking a different
        // left room.
        if (rightRooms.empty)
        {
//import std.stdio;writefln("left=%s NO MATCH, SKIPPING", leftRoom.region);
            continue;
        }

        auto rightRoom = rightRooms.pickOne;
        auto d = Door(root.axis);

        d.pos = rightRoom.basePos;
//import std;writefln("door=%s", d);
        leftRoom.node.doors ~= d;
        rightRoom.node.doors ~= d;
        return;
    }

    // If we got here, it means we're in trouble.
    throw new GenCorridorsException("No matching door placement found, give up");
}

unittest
{
    // Test case 1:
    //   0123456789
    // 0 ##########
    // 1 #   ######
    // 2 #   -    #
    // 3 #####    #
    // 4 #####    #
    // 5 ##########
    auto root = new MapNode;
    root.axis = 2;
    root.pivot = 5;

    root.left = new MapNode;
    root.left.interior = region(vec(0,0,1,1), vec(1,1,4,3));

    root.right = new MapNode;
    root.right.interior = region(vec(0,0,5,2), vec(1,1,9,5));

    auto bounds = region(vec(0,0,1,1), vec(1,1,10,6));
    genCorridors(root, bounds);

    assert(root.doors == []);
    assert(root.left.doors == [ Door(2, [0,0,4,2]) ]);
    assert(root.right.doors == [ Door(2, [0,0,4,2]) ]);
}

/**
 * Returns: true if the given door is valid for the given room interior, false
 * otherwise.
 */
bool isValidDoor()(Region!(int,4) interior, Door d)
{
    return iota(4)
        .map!(i => (i == d.axis) ? (d.pos[i] == interior.min[i] - 1 ||
                                    d.pos[i] == interior.max[i])
                                 : (interior.min[i] <= d.pos[i] &&
                                    d.pos[i] < interior.max[i]))
        .fold!((a,b) => a && b)(true);
}

unittest
{
    // Test case:
    //   01234
    // 0 #####
    // 1 #   #
    // 2 #   #
    // 3 #   #
    // 4 #####
    auto interior = region(vec(1,1,1,1), vec(4,4,4,4));

    assert( isValidDoor(interior, Door(0, [0,1,1,1])));
    assert(!isValidDoor(interior, Door(0, [1,1,1,1])));
    assert(!isValidDoor(interior, Door(0, [2,1,1,1])));
    assert(!isValidDoor(interior, Door(0, [3,1,1,1])));
    assert( isValidDoor(interior, Door(0, [4,1,1,1])));
    assert(!isValidDoor(interior, Door(0, [5,1,1,1])));

    assert( isValidDoor(interior, Door(1, [1,0,1,1])));
    assert(!isValidDoor(interior, Door(1, [1,1,1,1])));
    assert(!isValidDoor(interior, Door(1, [1,2,1,1])));
    assert(!isValidDoor(interior, Door(1, [1,3,1,1])));
    assert( isValidDoor(interior, Door(1, [1,4,1,1])));
    assert(!isValidDoor(interior, Door(1, [1,5,1,1])));

    assert(!isValidDoor(interior, Door(2, [2,2,0,0])));
    assert( isValidDoor(interior, Door(2, [2,2,0,1])));
    assert( isValidDoor(interior, Door(2, [2,2,0,2])));
    assert( isValidDoor(interior, Door(2, [2,2,0,3])));
    assert(!isValidDoor(interior, Door(2, [2,2,0,4])));
    assert(!isValidDoor(interior, Door(2, [2,2,0,5])));
}

/**
 * Sanity checker for door placements.
 */
bool doorsSanityCheck()(World w)
{
    bool result = true;
    foreachRoom(w.map.tree, w.map.bounds, (Region!(int,4) bounds, MapNode node)
    {
        foreach (d; node.doors)
        {
            if (!isValidDoor(node.interior, d))
            {
//import std;writefln("Interior check failed: interior=%s d=%s", node.interior, d);
                goto FAIL;
            }

            auto v = vec(0,0,0,0);
            v[d.axis] = 1;
            if (w.store.get!BlocksMovement(w.map[vec(d.pos) + v]) !is null ||
                w.store.get!BlocksMovement(w.map[vec(d.pos) - v]))
            {
//import std;writefln("Walkability test failed: interior=%s d=%s %s", node.interior, d, [vec(d.pos)+v, vec(d.pos), vec(d.pos)-v].map!(pos => w.getAllAt(Pos(pos)).map!(id => w.store.get!Name(id).name)));
                goto FAIL;
            }
        }
        return 0;

    FAIL:
        result = false;
        return 1;
    });
    return result;
}

unittest
{
    // Test case:
    //   0123456
    // 0 #######
    // 1 #  -  #
    // 2 #  #  #
    // 3 #######
    auto bounds = region(vec(0,0,0,0), vec(4,7,2,2));
    auto root = new MapNode;
    root.axis = 1;
    root.pivot = 4;

    root.left = new MapNode;
    root.left.interior = region(vec(1,1,0,0), vec(3,3,1,1));
    root.left.doors = [ Door(1, [1,3,0,0]) ];

    root.right = new MapNode;
    root.right.interior = region(vec(1,4,0,0), vec(3,6,1,1));
    root.right.doors = [ Door(1, [1,3,0,0]) ];

    auto w = new World;
    w.map.tree = root;
    w.map.bounds = bounds;

    assert(doorsSanityCheck(w));

    // Blocking objects are NOT included in the doors check, because e.g.,
    // creatures could be generated next to doors, but that does not make the
    // door placement wrong.
    w.store.createObj(Name("blocker"), BlocksMovement());
    assert(doorsSanityCheck(w));
}

/**
 * Given the boundary between two nodes and a list of doors, returns true if
 * there is at least one door in the list that lies on that boundary.
 *
 * Params:
 *  boundary = The boundary to check. The boundary should lie exactly between
 *      two BSP nodes, i.e., boundary.min[axis] == boundary.max[axis] ==
 *      rightNodeBounds.min[axis].
 *  axis = The axis of the connection (assumed to be the perpendicular of the
 *      boundary).
 *  doors = The list of doors to check.
 */
bool hasDoorAtBoundary(Region!(int,4) boundary, int axis, Door[] doors)
    in (boundary.min[axis] == boundary.max[axis])
{
    auto wall = boundary;
    wall.min[axis]--;

    foreach (d; doors)
    {
        if (wall.contains(vec(d.pos)))
            return true;
    }
    return false;
}

unittest
{
    auto r = region(vec(0,0,5,0), vec(5,5,5,5));
    assert( hasDoorAtBoundary(r, 2, [ Door(2, [1,1,4,1]) ]));
    assert( hasDoorAtBoundary(r, 2, [ Door(2, [0,0,4,0]) ]));
    assert( hasDoorAtBoundary(r, 2, [ Door(2, [4,4,4,4]) ]));

    assert(!hasDoorAtBoundary(r, 2, [ Door(0, [1,1,1,1]) ]));
    assert(!hasDoorAtBoundary(r, 2, [ Door(2, [1,1,1,1]) ]));
    assert(!hasDoorAtBoundary(r, 2, [ Door(2, [4,4,3,4]) ]));
    assert(!hasDoorAtBoundary(r, 2, [ Door(2, [4,4,5,4]) ]));

    assert( hasDoorAtBoundary(r, 2, [ Door(2, [6,2,4,2]),
                                      Door(2, [4,4,4,4]) ]));
}

/**
 * Insert additional doors to randomly-picked rooms outside of the BSP
 * connectivity structure, so that non-trivial topology is generated.
 *
 * Prerequisites: The .interior's of every room must have already been set,
 * usually via setRoomInteriors().
 *
 * Params:
 *  root = Root of BSP tree.
 *  region = Initial bounding region.
 *  count = Number of additional doors to insert.
 *  maxRetries = Maximum number of failures while looking for a room pair that
 *      can accomodate an extra door. This is to prevent infinite loops in case
 *      the given tree cannot accomodate another `count` doors.
 *  doorFilter = An optional delegate that accepts or rejects a door, and
 *      optionally marks it up in some way, e.g., with an .extra flag set, or
 *      some randomized door type. The delegate is passed the room nodes that
 *      it will connect. Returns: true if the door should be added, false
 *      otherwise. Note that returning false will count towards the number of
 *      failed attempts.
 *  pickAxis = An optional delegate that selects which axis to use for finding
 *      potential back-edges.
 *  allowMultiple = Whether or not to allow multiple doors on the same wall.
 *      Default: false.
 */
void genBackEdges(R)(MapNode root, R region, int count, int maxRetries = 15)
{
    import std.random : uniform;
    genBackEdges(root, region, count, maxRetries,
                 (in MapNode[2], ref Door) => true,
                 (MapNode node, R bounds) => uniform(0, 4),
                 false);
}

/// ditto
void genBackEdges(R)(MapNode root, R region, int count, int maxRetries,
                     bool delegate(in MapNode[2] node, ref Door) doorFilter,
                     int delegate(MapNode, R) pickAxis,
                     bool allowMultiple)
{
    import std.random : uniform;
    import rndutil : pickOne;
    while (count > 0 && maxRetries > 0)
    {
        static struct RightRoom
        {
            MapNode node;
            R region;
            int[4] basePos;
        }

        auto success = root.randomRoom(region, (MapNode node, R bounds) {
            // Randomly select a wall of the room.
            auto axis = pickAxis(node, bounds);
            if (axis == invalidAxis)
                return false;
            R wallFilt = rightWallFilt(node, bounds, axis);

//import std;writefln("left=%s (wallFilt=%s)", node.interior, wallFilt);
            // Find an adjacent room that can be joined to this one via a door.
            RightRoom[] targets;
            root.foreachFiltRoom(region, wallFilt, (MapNode node2, R r2) {
                import std.algorithm : canFind, filter, fold;
                import std.range : iota;

                auto wallFilt2 = leftWallFilt(node2, r2, axis);
                auto ir = wallFilt.intersect(wallFilt2);

//import std;writefln("left=%s (wallFilt=%s) right=%s (wallFilt2=%s) ir=%s", node.interior, wallFilt, node2.interior, wallFilt2, ir);
                // Check that there isn't already a door between these two
                // rooms.
                if (!allowMultiple && hasDoorAtBoundary(ir, axis, node.doors))
                    return 0;

                int[4] basePos;
                if (!randomEdgePos(ir, axis, basePos))
                {
                    // Overlap is too small to place a door, skip.
                    return 0;
                }

                // Avoid coincident doors
                if (node.doors.canFind!(d => d.pos == basePos))
                    return 0;

//import std;writefln("basePos=%s", basePos);
                targets ~= RightRoom(node2, r2, basePos);
                return 0;
            });

            if (targets.empty)
                return false; // couldn't match anything for this room

            auto rightRoom = targets.pickOne;

            auto d = Door(axis);
            d.pos = rightRoom.basePos;
            if (!doorFilter([node, rightRoom.node], d))
                return false;

            import std.format : format;
            assert(isValidDoor(node.interior, d) &&
                   isValidDoor(rightRoom.node.interior, d),
                   format("left.interior=%s right.interior=%s d=%s",
                          node.interior, rightRoom.node.interior, d));

//import std;writefln("door=%s", d);
            node.doors ~= d;
            rightRoom.node.doors ~= d;

            return true;
        });

        if (success)
            count--;
        else
            maxRetries--;
    }
}

unittest
{
    // Test case:
    //   012345678
    // 0 #########
    // 1 ##      #
    // 2 ##      #
    // 3 ##X###|##
    // 4 #  -    #
    // 5 #  #    #
    // 6 #########
    auto bounds = region(vec(1,1,0,0), vec(9,7,2,2));

    auto root = new MapNode;
    root.axis = 1;
    root.pivot = 4;

    root.left = new MapNode;
    root.left.interior = region(vec(2,1,0,0), vec(8,3,1,1));
    root.left.doors = [ Door(1, [6,3,0,0]) ];

    root.right = new MapNode;
    root.right.axis = 0;
    root.right.pivot = 4;

    root.right.left = new MapNode;
    root.right.left.interior = region(vec(1,4,0,0), vec(3,6,1,1));
    root.right.left.doors = [ Door(0, [3,4,0,0]) ];

    root.right.right = new MapNode;
    root.right.right.interior = region(vec(4,4,0,0), vec(8,6,1,1));
    root.right.right.doors = [ Door(1, [6,3,0,0]),
                               Door(0, [3,4,0,0]) ];

    genBackEdges(root, bounds, 1, 99, (in MapNode[2], ref Door) => true,
                 (MapNode, Region!(int,4)) => 1, false);
    assert(root.right.left.doors.canFind(Door(1, [2,3,0,0])));
}

/**
 * Returns: The minimum region of the given room node that covers all Doors.
 */
Region!(int,4) minCore(Region!(int,4) interior, Door[] doors)
    out(r; iota(4).all!(i => interior.min[i] <= r.min[i] &&
                             r.max[i] <= interior.max[i]))
{
    auto core = region(interior.max, interior.min);
    foreach (d; doors)
    {
        foreach (i; 0 .. 4)
        {
            if (i == d.axis)
            {
                if (core.min[i] > d.pos[i] + 1)
                    core.min[i] = d.pos[i] + 1;
                if (core.max[i] < d.pos[i])
                    core.max[i] = d.pos[i];
            }
            else
            {
                if (core.min[i] > d.pos[i])
                    core.min[i] = d.pos[i];
                if (core.max[i] < d.pos[i] + 1)
                    core.max[i] = d.pos[i] + 1;
            }
        }
    }
    return core;
}

unittest
{
    // Test case 1:
    //   012345
    // 0 ######
    // 1 -....#
    // 2 #....#
    // 3 #....#
    // 4 #....#
    // 5 ##-###
    auto r = region(vec(0,0,1,1), vec(1,1,5,5));
    auto doors = [
        Door(2, [0,0,0,1]),
        Door(3, [0,0,2,5]),
    ];

    assert(minCore(r, doors) == region(vec(0,0,1,1), vec(1,1,3,5)));

    // Test case 2:
    //   012345
    // 0 ######
    // 1 #....#
    // 2 #....#
    // 3 -....#
    // 4 #....#
    // 5 ##-###
    doors = [
        Door(2, [0,0,0,3]),
        Door(3, [0,0,2,5]),
    ];

    assert(minCore(r, doors) == region(vec(0,0,1,3), vec(1,1,3,5)));

    // Test case 3:
    //   012345
    // 0 ######
    // 1 #....#
    // 2 #....-
    // 3 #....#
    // 4 #....#
    // 5 ##-###
    doors = [
        Door(2, [0,0,5,2]),
        Door(3, [0,0,2,5]),
    ];

    assert(minCore(r, doors) == region(vec(0,0,2,2), vec(1,1,5,5)));

    // Test case 4:
    //   012345
    // 0 ###-##
    // 1 #....#
    // 2 #....-
    // 3 #....#
    // 4 #....#
    // 5 ######
    doors = [
        Door(2, [0,0,5,2]),
        Door(3, [0,0,3,0]),
    ];

    assert(minCore(r, doors) == region(vec(0,0,3,1), vec(1,1,5,3)));

    // Test case 5:
    //   012345
    // 0 ###-##
    // 1 #....#
    // 2 #....#
    // 3 #....#
    // 4 #....#
    // 5 ##-###
    doors = [
        Door(3, [0,0,3,0]),
        Door(3, [0,0,2,5]),
    ];

    assert(minCore(r, doors) == region(vec(0,0,2,1), vec(1,1,4,5)));

    // Test case 6:
    //   012345
    // 0 ###-##
    // 1 #....#
    // 2 -....#
    // 3 #....#
    // 4 #....#
    // 5 ######
    doors = [
        Door(2, [0,0,0,2]),
        Door(3, [0,0,3,0]),
    ];

    assert(minCore(r, doors) == region(vec(0,0,1,1), vec(1,1,4,3)));
}

/**
 * Iterate over leaf nodes in the given BSP tree and assign room interiors with
 * random sizes.
 *
 * Prerequisites: Initial (maximal) room interiors must have already been set.
 * Doors must have already been computed, since minimum room interior regions
 * are computed based on the position of doors.
 */
void resizeRooms(R)(MapNode root, R region)
    if (is(R == Region!(int,n), size_t n))
{
    foreachRoom(root, region, (R bounds, MapNode node) {
        import std.random : uniform;

        // Find minimum region room must cover in order for exits to connect.
        auto core = minCore(node.interior, node.doors);

        // Expand minimum region to be at least 3 tiles wide in each direction.
        foreach (i; 0 .. 4)
        {
            if (node.interior.length(i) < 3)
                continue;   // FIXME: should be an error

            while (core.length(i) < 3)
            {
                if (uniform(0, 2) == 0)
                {
                    if (node.interior.min[i] < core.min[i])
                        core.min[i]--;
                }
                else
                {
                    if (core.max[i] < node.interior.max[i])
                        core.max[i]++;
                }
            }
        }

        // Select random size between bounding region and minimum region.
        R result;
        foreach (i; 0 .. 4)
        {
            result.min[i] = uniform!"[]"(node.interior.min[i], core.min[i]);
            result.max[i] = uniform!"[]"(core.max[i], node.interior.max[i]);
        }

        node.interior = result;
        return 0;
    });
}

unittest
{
    // Test case: (base case)
    //   012345
    // 0 ####|#
    // 1 -    #
    // 2 #    -
    // 3 #|####
    auto bounds = region(vec(0,0,0,0), vec(6,4,2,2));
    auto root = new MapNode;
    root.interior = region(vec(1,1,0,0), vec(5,3,1,1));
    root.doors = [
        Door(0, [0,1,0,0]),
        Door(1, [4,1,0,0]),
        Door(0, [5,2,0,0]),
        Door(1, [1,3,0,0]),
    ];

    resizeRooms(root, bounds);

    assert(root.interior == region(vec(1,1,0,0), vec(5,3,1,1)));
}

/**
 * Generate ladders for reaching doors that are too high to reach from floor.
 *
 * Prerequisites: Room interiors must already have been set.
 */
void addLadders(World w, MapNode tree, Region!(int,4) bounds)
{
    foreachRoom(tree, bounds, (Region!(int,4) bounds, MapNode node) {
        foreach (d; node.doors)
        {
            if (d.axis == 0 && d.type == Door.Type.normal &&
                d.pos[0] < node.interior.min[0])
            {
                // Vertical exits
                foreach (i; d.pos[0] .. node.interior.max[0])
                {
                    createLadder(&w.store, Pos(i, d.pos[1], d.pos[2],
                                               d.pos[3]));
                }
            }
            else if (d.axis != 0 && d.pos[0] < node.interior.max[0] - 2)
            {
                // Horizontal exits
                auto pos = d.pos;
                pos[d.axis] = (d.pos[d.axis] == node.interior.max[d.axis]) ?
                              d.pos[d.axis] - 1 : d.pos[d.axis] + 1;
                foreach (i; d.pos[0] + 1 .. node.interior.max[0])
                {
                    createLadder(&w.store, Pos(i, pos[1], pos[2], pos[3]));
                }
            }
        }
        return 0;
    });
}

unittest
{
    import gamemap, terrain;

    // Test map:
    //    0123456
    //  0 ###=###
    //  1 #  =  #
    //  2 |_ =  #
    //  3 #= =  |
    //  4 #= =  #
    //  5 #######
    MapNode root = new MapNode;
    root.interior = Region!(int,4)(vec(1,1,1,1), vec(5,6,2,2));
    root.doors ~= Door(1, [2,0,1,1], Door.Type.normal);
    root.doors ~= Door(0, [0,3,1,1], Door.Type.normal);
    root.doors ~= Door(1, [3,6,1,1], Door.Type.normal);

    auto w = new World;
    w.map.tree = root;

    // Ladder placement should use interior, not bounding region.
    w.map.bounds = region(vec(0,0,0,0), vec(9,9,9,9));

    w.map.waterLevel = int.max;

    addLadders(w, w.map.tree, w.map.bounds);

    bool hasLadder(Pos pos)
    {
        return w.getAllAt(pos)
                .canFind!(id => w.store.get!Tiled(id).tileId == TileId.ladder);
    }

    assert(!hasLadder(Pos(0,1,1,1)));
    assert(!hasLadder(Pos(1,1,1,1)));
    assert(!hasLadder(Pos(2,1,1,1)));
    assert( hasLadder(Pos(3,1,1,1)));
    assert( hasLadder(Pos(4,1,1,1)));
    assert(!hasLadder(Pos(5,1,1,1)));

    assert( hasLadder(Pos(0,3,1,1)));
    assert( hasLadder(Pos(1,3,1,1)));
    assert( hasLadder(Pos(2,3,1,1)));
    assert( hasLadder(Pos(3,3,1,1)));
    assert( hasLadder(Pos(4,3,1,1)));
    assert(!hasLadder(Pos(5,3,1,1)));

    assert(!hasLadder(Pos(0,5,1,1)));
    assert(!hasLadder(Pos(1,5,1,1)));
    assert(!hasLadder(Pos(2,5,1,1)));
    assert(!hasLadder(Pos(3,5,1,1)));
    assert(!hasLadder(Pos(4,5,1,1)));
    assert(!hasLadder(Pos(5,5,1,1)));
}

unittest
{
    import gamemap, terrain;

    // Test map:
    //    0123456
    //  0 ###=###
    //  1 #  =  #
    //  2 #  = _|
    //  3 |  = =#
    //  4 #  = =#
    //  5 #######
    MapNode root = new MapNode;
    root.interior = Region!(int,4)(vec(1,1,1,1), vec(5,6,2,2));
    root.doors ~= Door(1, [3,0,1,1], Door.Type.normal);
    root.doors ~= Door(0, [0,3,1,1], Door.Type.normal);
    root.doors ~= Door(1, [2,6,1,1], Door.Type.normal);

    auto w = new World;
    w.map.tree = root;

    // Ladder placement should use interior, not bounding region.
    w.map.bounds = region(vec(0,0,0,0), vec(9,9,9,9));

    w.map.waterLevel = int.max;

    addLadders(w, w.map.tree, w.map.bounds);

    bool hasLadder(Pos pos)
    {
        return w.getAllAt(pos)
                .canFind!(id => w.store.get!Tiled(id).tileId == TileId.ladder);
    }

    assert(!hasLadder(Pos(0,1,1,1)));
    assert(!hasLadder(Pos(1,1,1,1)));
    assert(!hasLadder(Pos(2,1,1,1)));
    assert(!hasLadder(Pos(3,1,1,1)));
    assert(!hasLadder(Pos(4,1,1,1)));
    assert(!hasLadder(Pos(5,1,1,1)));

    assert( hasLadder(Pos(0,3,1,1)));
    assert( hasLadder(Pos(1,3,1,1)));
    assert( hasLadder(Pos(2,3,1,1)));
    assert( hasLadder(Pos(3,3,1,1)));
    assert( hasLadder(Pos(4,3,1,1)));
    assert(!hasLadder(Pos(5,3,1,1)));

    assert(!hasLadder(Pos(0,5,1,1)));
    assert(!hasLadder(Pos(1,5,1,1)));
    assert(!hasLadder(Pos(2,5,1,1)));
    assert( hasLadder(Pos(3,5,1,1)));
    assert( hasLadder(Pos(4,5,1,1)));
    assert(!hasLadder(Pos(5,5,1,1)));
}

/**
 * Randomly assign room floors.
 */
void setRoomFloors(R)(MapNode root, R bounds)
    if (is(R == Region!(int,n), size_t n))
{
    foreachRoom(root, bounds, (R r, MapNode node) {
        import std.random : uniform;
        auto x = uniform(0, 100);
        node.style = (x < 50) ? FloorStyle.bare :
                     (x < 80) ? FloorStyle.grassy :
                                FloorStyle.muddy;
        return 0;
    });
}

unittest
{
    import testutil;
    enum wd = 48, ht = 24;
    auto result = TestScreen!(wd,ht)();

    import std.algorithm : filter, clamp;
    import std.random : uniform;
    import std.range : iota;
    import rndutil;

    // Generate base BSP tree
    auto bounds = region(vec(1, 1, 0, 0), vec(wd, ht, 2, 2));
    alias R = typeof(bounds);

    auto tree = genBsp!MapNode(bounds,
        (R r) => r.length(0)*r.length(1) > 49 + uniform(0, 50),
        (R r) => iota(4).filter!(i => r.max[i] - r.min[i] > 8)
                        .pickOne(invalidAxis),
        (R r, int axis) => (r.max[axis] - r.min[axis] < 8) ?
            invalidPivot : uniform(r.min[axis]+4, r.max[axis]-3)
            //gaussian(r.max[axis] - r.min[axis], 4)
            //    .clamp(r.min[axis] + 3, r.max[axis] - 3)
    );

    auto w = new World;
    w.map.tree = tree;
    w.map.bounds = bounds;

    // Generate connecting corridors
    setRoomInteriors(w.map.tree, w.map.bounds);
    genCorridors(w.map.tree, w.map.bounds);
    assert(doorsSanityCheck(w));

    // Generate back edges
    genBackEdges!R(w.map.tree, w.map.bounds, 4, 15,
        (in MapNode[2] rooms, ref Door d) {
            d.type = Door.Type.extra;
            return true;
        },
        (MapNode node, R region) => uniform(0, 2), false
    );
    assert(doorsSanityCheck(w));

    resizeRooms(w.map.tree, w.map.bounds);
    assert(doorsSanityCheck(w));

    setRoomFloors(w.map.tree, w.map.bounds);

    version(none)
    {
        dumpBsp(result, w.map.tree, w.map.bounds);
        assert(0);
    }
}

/**
 * Returns: A random room in the given BSP tree that's completely above the
 * water level, null if all rooms are submerged (or partially so).
 *
 * Prerequisites: Room .interior's must have been set.
 */
MapNode randomDryRoom(World w)
    out(node; node is null || node.isLeaf())
{
    auto dryRegion = w.map.bounds;
    dryRegion.max[0] = w.map.waterLevel;

    MapNode dryRoom;
    int n = 0;
    foreachFiltRoom(w.map.tree, w.map.bounds, dryRegion,
        (MapNode node, Region!(int,4) r) {
            if (node.interior.max[0] > w.map.waterLevel)
                return 0; // reject partially-submerged rooms

            if (n == 0 || uniform(0, n) == 0)
            {
                dryRoom = node;
            }
            n++;
            return 0;
        }
    );
    return dryRoom;
}

unittest
{
    auto bounds = region(vec(0,0,0,0), vec(10,5,5,5));
    auto root = new MapNode;
    root.axis = 0;
    root.pivot = 5;

    root.left = new MapNode;
    root.left.interior = region(vec(0,0,0,0), vec(4,4,4,4));

    root.right = new MapNode;
    root.right.interior = region(vec(5,0,0,0), vec(9,4,4,4));

    auto w = new World;
    w.map.tree = root;
    w.map.bounds = bounds;

    w.map.waterLevel = 8;
    assert(randomDryRoom(w) is root.left);

    w.map.waterLevel = 5;
    assert(randomDryRoom(w) is root.left);

    w.map.waterLevel = 4;
    assert(randomDryRoom(w) is root.left);

    w.map.waterLevel = 3;
    assert(randomDryRoom(w) is null);
}

/**
 * Returns: A random floor location in the given BSP tree that's above the
 * water level.
 */
Vec!(int,4) randomDryPos(World w)
{
    auto dryRoom = randomDryRoom(w);
    return dryRoom.randomLocation(dryRoom.interior);
}

unittest
{
    auto bounds = region(vec(0,0,0,0), vec(10,5,5,5));
    auto root = new MapNode;
    root.axis = 0;
    root.pivot = 5;

    root.left = new MapNode;
    root.left.interior = region(vec(0,0,0,0), vec(4,4,4,4));

    root.right = new MapNode;
    root.right.interior = region(vec(5,0,0,0), vec(9,4,4,4));

    auto w = new World;
    w.map.tree = root;
    w.map.bounds = bounds;

    w.map.waterLevel = 7;
    auto pos = w.randomDryPos();
    assert(root.left.interior.contains(pos));
}

/**
 * Generate pits and pit traps.
 *
 * Params:
 *  w = The game world.
 *  count = The number of pit traps to attempt to place. Note that the actual
 *      number of traps generated may be lower than this, if there are too many
 *      failed attempts to find suitable locations for traps.
 *  openPitPct = Percentage of pits that will be visible open pits, vs. hidden
 *      traps.
 */
void genPitTraps(World w, MapNode tree, Region!(int,4) bounds, int count,
                 int openPitPct = 30)
{
    genBackEdges(tree, bounds, count, count*8,
        (in MapNode[2] rooms, ref Door d) {
            assert(d.axis == 0);

            bool nextToExisting;
            foreach (rm; rooms)
            {
                foreach (dd; rm.doors)
                {
                    if (dd.type == Door.Type.normal &&
                        iota(4).map!(i => abs(d.pos[i] - dd.pos[i])).sum == 1)
                    {
                        nextToExisting = true;
                    }

                    if (dd.axis != 0 &&
                        iota(1, 4).map!(i => abs(d.pos[i] - dd.pos[i]))
                                  .sum == 1)
                    {
                        // Don't place where a ladder would be placed.
                        return false;
                    }
                }
            }

            if (!nextToExisting && uniform(0, 100) < openPitPct)
            {
                // Non-hidden open pit.
                d.type = Door.Type.extra;
            }
            else
            {
                d.type = Door.Type.trapdoor;
                auto floorId = style2Terrain(rooms[0].style);
                w.store.createObj(Pos(vec(d.pos) + vec(-1,0,0,0)),
                                  Trigger(Trigger.Type.onEnter, w.triggerId));
                w.store.createObj(Pos(d.pos), Name("pit trap"),
                    Tiled(TileId.wall, -1), *w.store.get!TiledAbove(floorId),
                    BlocksMovement(Climbable.yes), BlocksView(),
                    Triggerable(w.triggerId, TriggerEffect.trapDoor));
                w.triggerId++;
            }
            return true;
        },
        (MapNode node, Region!(int,4) bounds) => 0, // always pick vertical
        true,   // allow multiple pit traps on same wall as normal door
    );
}

unittest
{
    // Test case:
    //   01234
    // 0 #####
    // 1 #   #
    // 2 ##X##
    // 3 #   #
    // 4 #   #
    // 5 #####
    auto bounds = region(vec(0,0,0,0), vec(6,5,2,2));
    auto root = new MapNode;
    root.axis = 0;
    root.pivot = 3;

    root.left = new MapNode;
    root.left.interior = region(vec(1,1,0,0), vec(2,4,1,1));
    root.left.style = FloorStyle.grassy;

    root.right = new MapNode;
    root.right.interior = region(vec(3,1,0,0), vec(5,4,1,1));
    root.right.style = FloorStyle.muddy;

    auto w = new World;
    w.map.tree = root;
    w.map.bounds = bounds;

    genPitTraps(w, root, bounds, 1, 0);

    auto r = w.store.getAll!Triggerable()
                    .map!(id => w.store.get!TiledAbove(id));
    assert(!r.empty);
    assert(r.front.tileId == TileId.floorGrassy);
}

/**
 * Generate rock traps.
 *
 * Prerequisites:
 * - Must be called *after resizeRooms(), addLadders(), setting of water
 *   levels, and placement of important level objects like portals, because
 *   this will generate traps on any unoccupied floor tile. (But it's probably
 *   OK to call this before placing gold, monsters, or other items: it will
 *   just be trapped gold. :-P)
 *
 * Note: this is done separately from genPitTraps because it needs rooms'
 * .interior to be already fixed.
 */
void genRockTraps(World w, int count)
{
    while (count > 0)
    {
        // Find unoccupied location.
        auto room = randomDryRoom(w);
        if (room is null)
            return; // everything is underwater; don't bother.

        auto pos = room.randomLocation(room.interior);
        auto floorPos = pos + vec(1,0,0,0);
        while (!w.store.getAllBy!Pos(Pos(pos)).empty ||
               !w.locationHas!BlocksMovement(floorPos))
        {
            pos = randomLocation(w.map.tree, w.map.bounds, false);
            floorPos = pos + vec(1,0,0,0);
        }

        auto ceilingPos = pos;
        ceilingPos[0] = room.interior.min[0];

        w.store.createObj(Pos(pos), Weight(1) /*FIXME:this is a hack*/,
                          Trigger(Trigger.Type.onWeight, w.triggerId, 500));
        w.store.createObj(Pos(ceilingPos),
                          Triggerable(w.triggerId, TriggerEffect.rockTrap));
        w.triggerId++;
        count--;
    }
}

/**
 * Locates the neighbour of the given node connected by the given door.
 */
MapNode findNgbr(R)(MapNode tree, R bounds, MapNode node, uint doorIdx)
    in (doorIdx < node.doors.length)
{
    // Compute coordinates of the other side of the door.
    auto d = node.doors[doorIdx];
    auto otherSide = vec(d.pos);
    otherSide[d.axis] += (d.pos[d.axis] == node.interior.max[d.axis]) ? 1 : -1;

    MapNode ngbr;
    Region!(int,4) ngbrBounds;
    foreachFiltRoom(tree, bounds, (R r) => r.contains(otherSide),
                    (MapNode n, R r1) {
                        assert(ngbr is null);
                        ngbr = n;
                        ngbrBounds = r1;
                        return 1;
                    });

    assert(ngbr !is null);
    return ngbr;
}

unittest
{
    //   0123456789
    // 0 ##########
    // 1 #   #    #
    // 2 #   #    #
    // 3 ##|##    #
    // 4 #   -    #
    // 5 #   #    #
    // 6 ##########
    auto root = new MapNode;
    root.axis = 2;
    root.pivot = 5;

    root.left = new MapNode;
    root.left.axis = 3;
    root.left.pivot = 4;
    root.left.left = new MapNode;
    root.left.left.doors ~= Door(3, [ 1, 1, 2, 3 ]);
    root.left.right = new MapNode;
    root.left.right.doors ~= Door(3, [ 1, 1, 2, 3 ]);
    root.left.right.doors ~= Door(2, [ 1, 1, 4, 4 ]);

    root.right = new MapNode;
    root.right.doors ~= Door(2, [ 1, 1, 4, 4 ]);

    auto bounds = region(vec(0,0,1,1), vec(2,2,10,7));
    setRoomInteriors(root, bounds);

    assert(findNgbr(root, bounds, root.right, 0) == root.left.right);
    assert(findNgbr(root, bounds, root.left.right, 0) == root.left.left);
    assert(findNgbr(root, bounds, root.left.right, 1) == root.right);
    assert(findNgbr(root, bounds, root.left.left, 0) == root.left.right);
}

/**
 * Adjusts doors heights to be flush against the highest floor they connect, so
 * that we avoid unnecessary ladders.
 */
void sinkDoors(MapNode tree, Region!(int,4) region)
{
    foreachRoom(tree, region, (Region!(int,4) bounds, MapNode node)
    {
        foreach (i, ref d; node.doors)
        {
            if (d.axis == 0) continue;
            auto ngbr = findNgbr(tree, region, node, cast(uint) i);
            auto upperFloor = min(node.interior.max[0], ngbr.interior.max[0]);
            d.pos[0] = upperFloor - 1;
        }
        return 0;
    });
}

unittest
{
    //   0123456789
    // 0 ##########
    // 1 #3  #4   #
    // 2 #   #    #
    // 3 ##|##    #
    // 4 #5  -    #
    // 5 #   #    #
    // 6 ##########
    auto root = new MapNode;
    root.axis = 2;
    root.pivot = 5;

    root.left = new MapNode;
    root.left.axis = 3;
    root.left.pivot = 4;
    root.left.left = new MapNode;
    root.left.left.doors ~= Door(3, [ 1, 1, 2, 3 ]);
    root.left.right = new MapNode;
    root.left.right.doors ~= Door(3, [ 1, 1, 2, 3 ]);
    root.left.right.doors ~= Door(2, [ 1, 1, 4, 4 ]);

    root.right = new MapNode;
    root.right.doors ~= Door(2, [ 1, 1, 4, 4 ]);

    auto bounds = region(vec(0,0,1,1), vec(5,2,10,7));
    setRoomInteriors(root, bounds);

    // Set floor heights
    root.left.left.interior.max[0] = 3;
    root.left.right.interior.max[0] = 5;
    root.right.interior.max[0] = 4;

    auto w = new World;
    w.map.tree = root;
    w.map.bounds = bounds;

    sinkDoors(w.map.tree, w.map.bounds);

    assert(root.left.left.doors == [
        Door(3, [ 2, 1, 2, 3 ]),
    ]);
    assert(root.left.right.doors == [
        Door(3, [ 2, 1, 2, 3 ]),
        Door(2, [ 3, 1, 4, 4 ]),
    ]);
    assert(root.right.doors == [
        Door(2, [ 3, 1, 4, 4 ]),
    ]);
}

/**
 * Places an exit portal.
 */
void genPortal(World w)
{
    // Pick a tile that isn't empty or has no floor support.
    auto pos = randomDryPos(w);
    while (!w.store.getAllBy!Pos(Pos(pos)).empty ||
           !w.locationHas!BlocksMovement(pos + vec(1,0,0,0)))
        pos = randomDryPos(w);

    w.store.createObj(Pos(pos), Tiled(TileId.portal), Name("exit portal"),
                      Usable(UseEffect.portal), Weight(1));
}

unittest
{
    auto node = new MapNode;
    node.interior = region(vec(0,0,0,0), vec(2,2,1,1));
    node.doors = [ Door(0, [2,0,0,0], Door.Type.trapdoor) ];

    auto w = new World;
    w.map.tree = node;
    w.map.bounds = region(vec(0,0,0,0), vec(3,3,2,2));
    w.map.waterLevel = int.max;

    foreach (_; 0 .. 10)
    {
        genPortal(w);

        auto r = w.store.getAll!Usable();
        assert(!r.empty);
        auto id = r.front;
        auto pos = *w.store.get!Pos(id);
        assert(pos == Pos(1,1,0,0));

        r.popFront;
        assert(r.empty);

        w.store.destroyObj(id);
    }
}

/**
 * A random variable bounded by a range.
 */
struct ValRange
{
    int min, max=1;
    int pick() { return uniform(min, max); }

    unittest
    {
        ValRange v;
        assert(v.pick == 0);
    }
}

/**
 * Map generation parameters.
 */
struct MapGenArgs
{
    Region!(int,4) region;
    ValRange nBackEdges;
    ValRange nPitTraps;
    ValRange nRockTraps;

    float goldPct;
    ValRange waterLevel = ValRange(int.max-1, int.max);
    ValRange nMonstersA;

    bool sinkDoors = true;
}

/**
 * Generate new game world using the BSP tree algorithm.
 */
World genBspLevel(MapGenArgs args, out int[4] startPos)
{
    auto w = new World;
    w.map.bounds = args.region;

    enum nRetries = 10;
    alias R = Region!(int,4);
    foreach (_; 0 .. nRetries)
    {
        w.map.tree = genBsp!MapNode(w.map.bounds,
            (R r) => r.volume > 24 + uniform(0, 80),
            (R r) => iota(4).filter!(i => r.max[i] - r.min[i] > 8)
                            .pickOne(invalidAxis),
            (R r, int axis) => (r.max[axis] - r.min[axis] < 8) ?
                invalidPivot : uniform(r.min[axis]+4, r.max[axis]-3)
        );

        setRoomInteriors(w.map.tree, w.map.bounds);
        try
        {
            genCorridors(w.map.tree, w.map.bounds);
            break;
        }
        catch (GenCorridorsException e)
        {
            // This tree can't be properly connected; try again with a
            // different tree.
            w.map.tree = null;
            //version(none)
            {
                import std.stdio;
                writefln("genCorridors failed (%s), retrying", e.msg);
            }
        }
    }

    if (w.map.tree is null)
        throw new Exception("Unable to generate map");

    setRoomFloors(w.map.tree, w.map.bounds);

    // Add back edges, regular and pits/pit traps.
    genBackEdges(w.map.tree, w.map.bounds, args.nBackEdges.pick,
                 args.nBackEdges.max + 15);
    genPitTraps(w, w.map.tree, w.map.bounds, args.nPitTraps.pick);

    resizeRooms(w.map.tree, w.map.bounds);
    if (args.sinkDoors)
        sinkDoors(w.map.tree, w.map.bounds);
    addLadders(w, w.map.tree, w.map.bounds);

    // Add water if necessary.
    w.map.waterLevel = args.waterLevel.pick;

    genPortal(w);
    genRockTraps(w, args.nRockTraps.pick);

    MapNode startRoom = randomDryRoom(w);
    startPos = startRoom.randomLocation(startRoom.interior);

    auto ngold = cast(int)(floorArea(w.map.tree) * args.goldPct / 100);

    foreach (i; 0 .. ngold)
    {
        w.store.createObj(Pos(randomLocation(w.map.tree, w.map.bounds)),
                          Tiled(TileId.gold), Name("gold"), Pickable(),
                          QuestItem(1), Stackable(1), Weight(1));
    }

    foreach (i; 0 .. args.nMonstersA.pick())
    {
        auto pos = randomLocation(w.map.tree, w.map.bounds);

        // Avoid placing monsters in player's starting room.
        while (startRoom.interior.contains(pos))
            pos = randomLocation(w.map.tree, w.map.bounds);

        w.store.createObj(Pos(pos), Name("conical creature"), Weight(1000),
                          Tiled(TileId.creatureA, 1, Tiled.Hint.dynamic),
                          BlocksMovement(), Agent(), Mortal(5,5),
                          CanMove(CanMove.Type.walk | CanMove.Type.climb));
    }

    // Generate random rocks as additional deco.
    // FIXME: this should be configurable.
    foreach (i; 0 .. 1 + floorArea(w.map.tree) * 2 / 100)
    {
        w.store.createObj(Pos(randomLocation(w.map.tree, w.map.bounds)),
                          Tiled(TileId.rock), Name("rock"), Pickable(),
                          Stackable(1), Weight(50));
    }

    return w;
}

// Mapgen sanity tests.
unittest
{
    foreach (i; 0 .. 12)
    {
        int[4] startPos;
        MapGenArgs args;
        args.region = region(vec(0,0,0,0), vec(10,10,10,10));
        auto w = genBspLevel(args, startPos);

        // Door placement checks.
        foreachRoom(w.map.tree, w.map.bounds,
            (Region!(int,4) region, MapNode node) {
                foreach (i; 0 .. node.doors.length-1)
                {
                    auto d1 = node.doors[i];
                    auto pos1 = d1.pos;
                    foreach (j; i+1 .. node.doors.length)
                    {
                        auto d2 = node.doors[j];
                        auto pos2 = d2.pos;

                        // No coincident doors.
                        assert(pos1 != pos2);

                        // Only trapdoors/pits are allowed to be adjacent to
                        // another door.
                        if (iota(4).map!(i => abs(pos1[i] - pos2[i])).sum == 1)
                        {
                            assert(d1.type != Door.Type.normal ||
                                   d2.type != Door.Type.normal);
                        }
                    }

                    // Trapdoors & pits not allowed where ladders would be
                    // placed.
                    if (d1.type != Door.Type.normal)
                    {
                        foreach (j; 0 .. node.doors.length)
                        {
                            auto d2 = node.doors[j];
                            auto pos2 = d2.pos;

                            if (i == j || d2.axis == 0)
                                continue;

                            assert(iota(1,4).map!(i => abs(pos1[i] - pos2[i]))
                                            .sum != 1);
                        }
                    }
                }
                return 0;
            }
        );

        // Water level tests.
        import std.format : format;
        assert(startPos[0] < w.map.waterLevel,
               format("startPos %s below water level %d", startPos,
                      w.map.waterLevel));
        foreach (pos; w.store.getAll!Usable()
                       .filter!(id => w.store.get!Usable(id).effect ==
                                      UseEffect.portal)
                       .map!(id => w.store.get!Pos(id))
                       .filter!(posp => posp !is null)
                       .map!(posp => *posp))
        {
            assert(pos[0] < w.map.waterLevel,
                   format("Portal %s below water level %d", pos,
                          w.map.waterLevel));
        }
    }
}

/**
 * Generate tutorial level.
 *
 * For now, this returns a hard-coded level.  Later on we can extend this to
 * have more randomized elements.
 */
World genTutorialLevel(out int[4] startPos)
{
    auto w = new World;

    startPos = [1,1,1,1];

    // Left/right corridor
    auto cor1 = new MapNode;
    cor1.interior = region(vec(1,1,1,1), vec(2,2,2,6));
    cor1.doors ~= Door(2, [1,1,2,5], Door.Type.normal);

    // Front/back corridor
    auto cor2 = new MapNode;
    cor2.interior = region(vec(1,1,3,5), vec(2,2,6,6));
    cor2.doors ~= Door(2, [1,1,2,5], Door.Type.normal);
    cor2.doors ~= Door(1, [1,2,5,5], Door.Type.normal);

    // Ana/kata corridor
    auto cor3 = new MapNode;
    cor3.interior = region(vec(1,3,5,5), vec(2,6,6,6));
    cor3.doors ~= Door(1, [1,2,5,5], Door.Type.normal);
    cor3.doors ~= Door(0, [2,5,5,5], Door.Type.normal);

    // Up/down shaft with ladder
    auto cor4 = new MapNode;
    cor4.interior = region(vec(3,5,5,5), vec(6,6,6,6));
    cor4.doors ~= Door(0, [2,5,5,5], Door.Type.normal);
    cor4.doors ~= Door(3, [5,5,5,4], Door.Type.normal);

    // Final room
    auto room = new MapNode;
    room.interior = region(vec(3,3,3,1), vec(6,6,6,4));
    room.doors ~= Door(3, [5,5,5,4], Door.Type.normal);

    // A BSP tree to put them all together.
    auto root = new MapNode;
    root.axis = 0;
    root.pivot = 3;

    root.left = new MapNode;
    root.left.axis = 1;
    root.left.pivot = 3;
    root.left.left = new MapNode;
    root.left.right = cor3;

    root.left.left.axis = 2;
    root.left.left.pivot = 3;
    root.left.left.left = cor1;
    root.left.left.right = cor2;

    root.right = new MapNode;
    root.right.axis = 3;
    root.right.pivot = 5;
    root.right.left = room;
    root.right.right = cor4;

    root.interior = region(vec(0,0,0,0), vec(7,7,7,7));

    w.map.tree = root;
    w.map.bounds = root.interior;
    w.map.waterLevel = int.max;

    addLadders(w, w.map.tree, w.map.bounds);

    // Put some gold for the player to collect.
    enum goldPos = [
        Pos(5,3,3,3),
        Pos(5,3,5,1),
        Pos(5,3,5,3),
        Pos(5,5,3,1),
        Pos(5,5,3,3),
        Pos(5,5,5,1),
    ];
    foreach (pos; goldPos)
    {
        w.store.createObj(pos, Tiled(TileId.gold), Name("gold"), Pickable(),
                          QuestItem(1), Stackable(1), Weight(1));
    }

    // Some in-game instructions to guide the player along.
    w.store.createObj(Pos(1,1,1,1), Message([
        "This is the tutorial training area.",
        "Use the 'j' and 'k' keys to move left/right.",
    ]));
    w.store.createObj(Pos(1,1,1,5), Message([
        "Good!",
        "Now use the 'n' and 'o' keys to move forwards/backwards.",
    ]));
    w.store.createObj(Pos(1,1,5,5), Message([
        "Very good!",
        "Next, use the 'h' and 'l' keys to move ana/kata.",
    ]));
    w.store.createObj(Pos(1,5,5,5), Message([
        "Excellent!",
        "Use the 'i' and 'm' keys to climb up/down.",
    ]));
    w.store.createObj(Pos(5,5,5,5), Message([
        "Well done.",
        "Now collect all the gold ores, then head to the portal.",
    ]));
    w.store.createObj(Pos(5,5,5,3), Message([
        "At any time, press '?' for help.",
    ]));

    // An exit portal to end the tutorial.
    w.store.createObj(Pos(5,3,3,1), Tiled(TileId.portal), Name("exit portal"),
                      Usable(UseEffect.portal),
                      Message([
                        "This is the exit portal.",
                        "Press Enter to activate it."
                      ]));

    return w;
}

version(none) // level gen stress test
unittest
{
    import std.stdio;
    MapGenArgs args;
    args.region = region(vec(0,0,0,0), vec(64,64,64,64));
    args.nBackEdges = ValRange(20, 50);
    args.nPitTraps = ValRange(50, 80);
    args.goldPct = 0.2;
    args.waterLevel = ValRange(16, 64);
    args.nMonstersA = ValRange(20, 30);

    foreach (i; 0 .. 50)
    {
        int[4] startPos;
        World w;
        for (;;)
        {
            try {
                w = genBspLevel(args, startPos);
                assert(doorsSanityCheck(w));
                break;
            } catch (Exception e) {
                writefln("[%d] oops: %s", i, e.msg);
            }
        }
        if (w is null)
            writefln("[%d] WAT?!", i);
        else
            writefln("[%d] %d gold", i, w.store.getAll!QuestItem().count);
    }
}

/**
 * Scratch pad function for generating various test levels.
 */
World genTestLevel()(out int[4] startPos)
{
    auto w = new World;

    startPos = [1,1,1,1];
    auto root = new MapNode;
    root.interior = region(vec(1,1,1,1), vec(5,4,6,6));

    w.map.tree = root;
    w.map.bounds = region(vec(0,0,0,0), vec(6,5,7,7));
    w.map.waterLevel = 2;

    auto trigger = w.store.createObj(Pos(4,2,3,3), Name("trap"),
                                     Trigger(Trigger.Type.onWeight,
                                             w.triggerId, 50));
    auto rocktrap = w.store.createObj(Pos(1,2,3,3),
                                      Triggerable(w.triggerId,
                                                  TriggerEffect.rockTrap));
    w.triggerId++;

    return w;
}

// vim:set ai sw=4 ts=4 et:
