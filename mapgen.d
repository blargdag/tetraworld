/**
 * Map generation module.
 * ----------------------------------------------------------------------------
 * Map representation notes:
 *
 * Maps are represented using BSP trees (see bsp.d). The default map generators
 * use genBsp() to create a random BSP tree, subject to some constraints, but
 * it can be generated by any means you wish (see genTutorialLevel() for
 * example).  Rooms are assumed to occupy one leaf node (MapNode) each.
 *
 * Doors must be duplicated in *both* rooms that they connect. This doesn't
 * matter during map rendition (leftmost doors do not get rendered), but it
 * *does* matter during map generation because, e.g., leftmost doors are
 * required to generate ladder objects, otherwise there would be no ladders
 * connecting to leftmost doors.
 *
 * The actual size of the room may differ from the BSP node's bounding region;
 * the .interior of the room represents the actual interior of the room (NOT
 * including any outer walls).
 *
 * Copyright: (C) 2012-2021  blargdag@quickfur.ath.cx
 *
 * This file is part of Tetraworld.
 *
 * Tetraworld is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free
 * Software Foundation, either version 2 of the License, or (at your option)
 * any later version.
 *
 * Tetraworld is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * Tetraworld.  If not, see <http://www.gnu.org/licenses/>.
 */
module mapgen;

import std.algorithm;
import std.math : abs;
import std.random : uniform;
import std.range;
import std.typecons : Tuple, tuple;

import bsp;
import components;
import gamemap;
import objects;
import rndutil;
import terrain;
import vector;
import world;

/**
 * Initialize room interiors to the maximum size per BSP node, minus a 1-tile
 * space for the inter-room walls.
 */
void setRoomInteriors(MapNode root, Region4 bounds)
{
    foreachRoom(root, bounds, (Region4 r, MapNode node) {
        auto room = node.isRoom;
        if (room !is null)
            room.interior = region(r.min, r.max - vec(1,1,1,1));
        return 0;
    });
}

unittest
{
    // Test case 1:
    //   0123456789
    // 0 ##########
    // 1 #   #    #
    // 2 #   #    #
    // 3 #####    #
    // 4 #   #    #
    // 5 #   #    #
    // 6 ##########
    auto root = new MapNode;
    root.axis = 2;
    root.pivot = 5;

    root.left = new MapNode;
    root.left.axis = 3;
    root.left.pivot = 4;
    root.left.left = new RoomNode;
    root.left.right = new RoomNode;

    root.right = new RoomNode;

    auto bounds = region(vec(0,0,1,1), vec(2,2,10,7));
    setRoomInteriors(root, bounds);

    assert(root.left.left.isRoom.interior == region(vec(0,0,1,1), vec(1,1,4,3)));
    assert(root.left.right.isRoom.interior == region(vec(0,0,1,4), vec(1,1,4,6)));
    assert(root.right.isRoom.interior == region(vec(0,0,5,1), vec(1,1,9,6)));
}

private class GenCorridorsException : Exception
{
    this(string msg) { super(msg); }
}

/**
 * Prerequisities: The .interior of the node must have already been set.
 *
 * Returns: The filter region corresponding to the rightmost wall of the given
 * node along the given axis. (Note that it is not the *actual* rightmost wall,
 * since that lies inside the node bounds, whereas the wall filter lies 1 tile
 * past that in order to intersect with the adjacent room's bounds.)
 */
Region4 rightWallFilt(MapNode node, Region4 bounds, int axis)
{
    auto filt = region(bounds.min, bounds.max - vec(1,1,1,1));
    filt.min[axis] = filt.max[axis] = bounds.max[axis];
    return filt;
}

unittest
{
    auto node = new BuildNode;
    auto bounds = region(vec(1,1,1,1), vec(5,5,5,5));
    assert(rightWallFilt(node, bounds, 0) ==
           region(vec(5,1,1,1), vec(5,4,4,4)));
}

/**
 * Prerequisities: The .interior of the node must have already been set.
 *
 * Returns: The filter region corresponding to the leftmost wall of the given
 * node along the given axis. (Note that it is not the *actual* leftmost wall,
 * since that lies outside the node bounds, whereas the wall filter lies along
 * the first row of tiles in the room's interior in order to intersect with the
 * adjacent room's filter.)
 */
Region4 leftWallFilt(MapNode node, Region4 bounds, int axis)
{
    auto filt = region(bounds.min, bounds.max - vec(1,1,1,1));
    filt.min[axis] = filt.max[axis] = bounds.min[axis];
    return filt;
}

unittest
{
    auto node = new BuildNode;
    auto bounds = region(vec(1,1,1,1), vec(5,5,5,5));
    assert(leftWallFilt(node, bounds, 0) ==
           region(vec(1,1,1,1), vec(1,4,4,4)));
}

/**
 * Generate a random position corresponding to a door in the given intersection
 * of two wall filters.
 *
 * Returns: true if successful, false if a suitable position could not be
 * found.
 */
bool randomEdgePos(Region4 ir, int axis, out int[4] basePos)
    in (ir.min[axis] == ir.max[axis])
{
    foreach (i; 0 .. 4)
    {
        import std.random : uniform;
        if (i == axis)
        {
            assert(ir.min[i] == ir.max[i]);
            basePos[i] = ir.min[i] - 1;
        }
        else if (ir.max[i] - ir.min[i] > 0)
            basePos[i] = uniform(ir.min[i], ir.max[i]);
        else
        {
            // Overlap is too small to place a door, skip.
            return false;
        }
    }
    return true;
}

/**
 * Iterate over pairs of rightmost nodes in the left subtree and leftmost nodes
 * in the right subtree that share a wall in which a door can be inserted to
 * connect the left subtree to the right subtree.
 *
 * Params:
 *  root = The root of the BSP tree.
 *  region = The bounding region.
 *  dg = The delegate to invoke on each connecting wall candidate. It should
 *      return 0 to continue iteration, or non-zero to terminate iteration.
 *      The overload that takes a delegate with an int[4] parameter will
 *      randomly pick a door location within the wall candidate.
 */
void foreachCandidateDoor(MapNode root, Region4 region,
                          scope int delegate(MapNode left, MapNode right,
                                             Region4 ir) dg)
{
    root.left.foreachFiltRoom(leftRegion(region, root.axis, root.pivot),
        (Region4 r) => r.max[root.axis] >= root.pivot,
        (MapNode node1, Region4 r1)
    {
        Region4 wallFilt = rightWallFilt(node1, r1, root.axis);

        return root.right.foreachFiltRoom(
            rightRegion(region, root.axis, root.pivot), wallFilt,
            (MapNode node2, Region4 r2)
        {
            auto wallFilt2 = leftWallFilt(node2, r2, root.axis);

            auto ir = wallFilt.intersect(wallFilt2);
            if (!iota(4).map!(i => i == root.axis || ir.max[i] - ir.min[i] > 0)
                        .fold!((a,b) => a && b)(true))
            {
                // No overlap or too narrow, skip.
                return 0;
            }

            return dg(node1, node2, ir);
        });
    });
}

/// ditto
void foreachCandidateDoor(MapNode root, Region4 region,
                          scope int delegate(MapNode left, MapNode right,
                                             int[4] doorPos) dg)
{
    foreachCandidateDoor(root, region,
        (MapNode left, MapNode right, Region4 ir)
    {
        int[4] pos;
        foreach (i; 0 .. 4)
        {
            if (ir.min[i] < ir.max[i])
                pos[i] = uniform(ir.min[i], ir.max[i]);
            else
                pos[i] = ir.max[i] - 1;
        }
        return dg(left, right, pos);
    });
}

unittest
{
    // Test case 1:
    //   0123456
    // 0 #######
    // 1 #  #  #
    // 2 #######
    auto root = new MapNode;
    root.axis = 2;
    root.pivot = 4;
    root.left = new BuildNode;
    root.right = new BuildNode;

    auto bounds = region(vec(0,0,1,1), vec(2,2,7,3));

    MapNode[2][] pairs;
    int[] ys;

    foreachCandidateDoor(root, bounds, (MapNode left, MapNode right,
                                        Region4 ir)
    {
        pairs ~= [ left, right ];
        assert(ir == region(vec(0,0,4,1), vec(1,1,4,2)));
        ys ~= ir.min[3];
        return 0;
    });

    auto expected = [
        [ root.left, root.right ],
    ];
    assert(pairs == expected);

    assert(ys[0] == 1);
}

unittest
{
    // Test case 2:
    //   0123456789
    // 0 ##########
    // 1 #  #  #  #
    // 2 #  #  #  #
    // 3 #######  #
    // 4 #     #  #
    // 5 #     ####
    // 6 #     #  #
    // 7 #     #  #
    // 8 ##########
    auto root = new MapNode;
    root.axis = 2;
    root.pivot = 7;

    root.left = new MapNode;
    root.left.axis = 3;
    root.left.pivot = 4;

    root.left.left = new MapNode;
    root.left.left.axis = 2;
    root.left.left.pivot = 4;
    root.left.left.left = new BuildNode;
    root.left.left.right = new BuildNode;

    root.left.right = new BuildNode;

    root.right = new MapNode;
    root.right.axis = 3;
    root.right.pivot = 6;
    root.right.left = new BuildNode;
    root.right.right = new BuildNode;

    auto bounds = region(vec(0,0,1,1), vec(2,2,10,9));

    MapNode[][] pairs;
    int[] ys;

    foreachCandidateDoor(root, bounds, (MapNode left, MapNode right,
                                        Region4 ir)
    {
        pairs ~= [ left, right ];
        assert(ir.min[0] == 0);
        assert(ir.min[1] == 0);
        assert(ir.min[2] == 7);
        ys ~= ir.min[3];
        return 0;
    });

    MapNode[][] expected = [
        [ root.left.left.right, root.right.left ],
        [ root.left.right, root.right.left ],
        [ root.left.right, root.right.right ],
    ];
    assert(pairs.equal!equal(expected));

    assert(1 <= ys[0] && ys[0] < 3);
    assert(ys[1] == 4);
    assert(6 <= ys[2] && ys[2] < 8);
}

/**
 * Generate corridors based on BSP tree structure.
 *
 * Returns: false if the given BSP tree does not allow doors to be placed
 * according to the BSP connectivity structure. This is pretty rare but *does*
 * happen (2-8% for a 64^4 map, seems rarer on smaller maps), so the caller
 * should check for this and rebuild with a different BSP tree instead.
 */
bool genCorridors(MapNode root, Region4 region)
{
    if (root.isLeaf) return true;

    if (!genCorridors(root.left, leftRegion(region, root.axis, root.pivot)))
        return false;
    if (!genCorridors(root.right, rightRegion(region, root.axis, root.pivot)))
        return false;

    BuildNode[2] candidate;
    Region4 wall;
    int[4] basePos;
    int n;

    foreachCandidateDoor(root, region, (MapNode left, MapNode right,
                                        Region4 ir)
    {
        auto l = left.isBuildNode;
        auto r = right.isBuildNode;

        if (l is null || r is null)
            return 0;

        if (uniform(0, ++n) == 0)
        {
            candidate[0] = l;
            candidate[1] = r;
            wall = ir;
        }
        return 0;
    });

    if (n == 0)
        return false;

    assert(candidate[0] !is null && candidate[1] !is null);

    candidate[0].ngbrs ~= BuildNode.Ngbr(candidate[1], wall);
    candidate[1].ngbrs ~= BuildNode.Ngbr(candidate[0], wall);

    return true;
}

unittest
{
    // Test case 1:
    //   0123456789
    // 0 ##########
    // 1 #   #    #
    // 2 #   -    #
    // 3 #   #    #
    // 4 #   #    #
    // 5 ##########
    auto root = new MapNode;
    root.axis = 2;
    root.pivot = 5;

    root.left = new BuildNode;
    // region(vec(0,0,1,1), vec(1,1,4,3));

    root.right = new BuildNode;
    // region(vec(0,0,5,2), vec(1,1,9,5));

    auto bounds = region(vec(0,0,1,1), vec(2,2,10,6));
    while (!genCorridors(root, bounds)) {}

    assert(root.left.isBuildNode.ngbrs == [
        BuildNode.Ngbr(root.right, region(vec(0,0,5,1), vec(1,1,5,5)))
    ]);
    assert(root.right.isBuildNode.ngbrs == [
        BuildNode.Ngbr(root.left, region(vec(0,0,5,1), vec(1,1,5,5)))
    ]);
}

/**
 * Returns: true if the given door is valid for the given room interior, false
 * otherwise.
 */
bool isValidDoor()(Region4 interior, Door d)
{
    return iota(4)
        .map!(i => (i == d.axis) ? (d.pos[i] == interior.min[i] - 1 ||
                                    d.pos[i] == interior.max[i])
                                 : (interior.min[i] <= d.pos[i] &&
                                    d.pos[i] < interior.max[i]))
        .fold!((a,b) => a && b)(true);
}

unittest
{
    // Test case:
    //   01234
    // 0 #####
    // 1 #   #
    // 2 #   #
    // 3 #   #
    // 4 #####
    auto interior = region(vec(1,1,1,1), vec(4,4,4,4));

    assert( isValidDoor(interior, Door(0, [0,1,1,1])));
    assert(!isValidDoor(interior, Door(0, [1,1,1,1])));
    assert(!isValidDoor(interior, Door(0, [2,1,1,1])));
    assert(!isValidDoor(interior, Door(0, [3,1,1,1])));
    assert( isValidDoor(interior, Door(0, [4,1,1,1])));
    assert(!isValidDoor(interior, Door(0, [5,1,1,1])));

    assert( isValidDoor(interior, Door(1, [1,0,1,1])));
    assert(!isValidDoor(interior, Door(1, [1,1,1,1])));
    assert(!isValidDoor(interior, Door(1, [1,2,1,1])));
    assert(!isValidDoor(interior, Door(1, [1,3,1,1])));
    assert( isValidDoor(interior, Door(1, [1,4,1,1])));
    assert(!isValidDoor(interior, Door(1, [1,5,1,1])));

    assert(!isValidDoor(interior, Door(2, [2,2,0,0])));
    assert( isValidDoor(interior, Door(2, [2,2,0,1])));
    assert( isValidDoor(interior, Door(2, [2,2,0,2])));
    assert( isValidDoor(interior, Door(2, [2,2,0,3])));
    assert(!isValidDoor(interior, Door(2, [2,2,0,4])));
    assert(!isValidDoor(interior, Door(2, [2,2,0,5])));
}

/**
 * Sanity checker for door placements.
 */
bool doorsSanityCheck()(World w)
{
    bool result = true;
    foreachRoom(w.map.tree, w.map.bounds, (Region4 bounds, MapNode n)
    {
        auto node = n.isRoom; // FIXME this function should be in RoomNode instead
        if (n is null)
            return 0;

        foreach (d; node.doors)
        {
            import std.stdio : writefln;
            if (!isValidDoor(node.interior, d))
            {
                writefln("Interior check failed: interior=%s d=%s",
                         node.interior, d);
                goto FAIL;
            }

            auto v = vec(0,0,0,0);
            v[d.axis] = 1;
            if (w.store.get!BlocksMovement(w.map[vec(d.pos) + v]) !is null ||
                w.store.get!BlocksMovement(w.map[vec(d.pos) - v]))
            {
                writefln("Walkability test failed: interior=%s d=%s %s",
                    node.interior, d,
                    [ vec(d.pos)+v, vec(d.pos), vec(d.pos)-v ]
                        .map!(pos => w.getAllAt(Pos(pos))
                                      .map!(id => w.store.get!Name(id).name))
                );
                goto FAIL;
            }
        }
        return 0;

    FAIL:
        result = false;
        return 1;
    });
    return result;
}

unittest
{
    // Test case:
    //   0123456
    // 0 #######
    // 1 #  -  #
    // 2 #  #  #
    // 3 #######
    auto bounds = region(vec(0,0,0,0), vec(4,7,2,2));
    auto root = new MapNode;
    root.axis = 1;
    root.pivot = 4;

    root.left = new RoomNode;
    root.left.isRoom.interior = region(vec(1,1,0,0), vec(3,3,1,1));
    root.left.isRoom.doors = [ Door(1, [1,3,0,0]) ];

    root.right = new RoomNode;
    root.right.isRoom.interior = region(vec(1,4,0,0), vec(3,6,1,1));
    root.right.isRoom.doors = [ Door(1, [1,3,0,0]) ];

    auto w = new World;
    w.map.tree = root;
    w.map.bounds = bounds;

    assert(doorsSanityCheck(w));

    // Blocking objects are NOT included in the doors check, because e.g.,
    // creatures could be generated next to doors, but that does not make the
    // door placement wrong.
    w.store.createObj(Name("blocker"), BlocksMovement());
    assert(doorsSanityCheck(w));
}

/**
 * Given the boundary between two nodes and a list of doors, returns true if
 * there is at least one door in the list that lies on that boundary.
 *
 * Params:
 *  boundary = The boundary to check. The boundary should lie exactly between
 *      two BSP nodes, i.e., boundary.min[axis] == boundary.max[axis] ==
 *      rightNodeBounds.min[axis].
 *  axis = The axis of the connection (assumed to be the perpendicular of the
 *      boundary).
 *  doors = The list of doors to check.
 */
bool hasDoorAtBoundary(Region4 boundary, int axis, Door[] doors)
    in (boundary.min[axis] == boundary.max[axis])
{
    auto wall = boundary;
    wall.min[axis]--;

    foreach (d; doors)
    {
        if (wall.contains(vec(d.pos)))
            return true;
    }
    return false;
}

unittest
{
    auto r = region(vec(0,0,5,0), vec(5,5,5,5));
    assert( hasDoorAtBoundary(r, 2, [ Door(2, [1,1,4,1]) ]));
    assert( hasDoorAtBoundary(r, 2, [ Door(2, [0,0,4,0]) ]));
    assert( hasDoorAtBoundary(r, 2, [ Door(2, [4,4,4,4]) ]));

    assert(!hasDoorAtBoundary(r, 2, [ Door(0, [1,1,1,1]) ]));
    assert(!hasDoorAtBoundary(r, 2, [ Door(2, [1,1,1,1]) ]));
    assert(!hasDoorAtBoundary(r, 2, [ Door(2, [4,4,3,4]) ]));
    assert(!hasDoorAtBoundary(r, 2, [ Door(2, [4,4,5,4]) ]));

    assert( hasDoorAtBoundary(r, 2, [ Door(2, [6,2,4,2]),
                                      Door(2, [4,4,4,4]) ]));
}

/**
 * Insert additional doors to randomly-picked BuildNodes outside of the BSP
 * connectivity structure, so that non-trivial topology is generated.
 *
 * Params:
 *  root = Root of BSP tree.
 *  region = Initial bounding region.
 *  count = Number of back-edges to insert.
 *  maxRetries = Maximum number of failures while looking for a room pair that
 *      can accomodate an extra edge. This is to prevent infinite loops in case
 *      the given tree cannot accomodate another `count` doors.
 */
void genBackEdges(MapNode root, Region4 region, int count, int maxRetries = 15)
{
    import std.random : uniform;
    import rndutil : pickOne;

    static struct RightRoom
    {
        BuildNode node;
        Region4 region;
    }

    bool tryAddEdge(BuildNode node, Region4 bounds)
    {
        // Randomly select a wall of the room.
        auto axis = uniform(0, 4);
        Region4 wallFilt = rightWallFilt(node, bounds, axis);

        // Find an adjacent room that can be joined to this one via a door.
        RightRoom[] targets;
        root.foreachFiltRoom(region, wallFilt, (MapNode n2, Region4 r2) {
            import std.algorithm : canFind, filter, fold;
            import std.range : iota;

            auto node2 = n2.isBuildNode;
            if (node2 is null) return 0;

            auto wallFilt2 = leftWallFilt(node2, r2, axis);
            auto ir = wallFilt.intersect(wallFilt2);

            if (!iota(4).map!(i => i == root.axis || ir.max[i] - ir.min[i] > 0)
                        .fold!((a,b) => a && b)(true))
            {
                // No overlap or too narrow, skip.
                return 0;
            }

            // Skip if there's already an edge between these two rooms.
            if (node.ngbrs.canFind!(ngbr => ngbr.node is node2))
                return 0;

            targets ~= RightRoom(node2, ir);
            return 0;
        });

        if (targets.empty)
            return false; // couldn't match anything for this room

        auto rightRoom = targets.pickOne;
        node.ngbrs ~= BuildNode.Ngbr(rightRoom.node, rightRoom.region, true);
        rightRoom.node.ngbrs ~= BuildNode.Ngbr(node, rightRoom.region, true);

        return true;
    }

    while (count > 0 && maxRetries > 0)
    {
        auto nb = randomRoom(root, region, Distrib.volume);
        auto node = nb[0].isBuildNode;
        auto bounds = nb[1];

        if (node !is null && tryAddEdge(node, bounds))
            count--;
        else
            maxRetries--;
    }
}

unittest
{
    // Test case:
    //   012345678
    // 0 #########
    // 1 #       #
    // 2 #       #
    // 3 ##X###|##
    // 4 #  -    #
    // 5 #  #    #
    // 6 #########
    auto bounds = region(vec(1,1,0,0), vec(9,7,2,2));

    auto root = new MapNode;
    root.axis = 1;
    root.pivot = 4;

    root.left = new BuildNode(region(vec(1,1,0,0), vec(9,4,2,2)));

    root.right = new MapNode;
    root.right.axis = 0;
    root.right.pivot = 4;

    root.right.left = new BuildNode(region(vec(1,4,0,0), vec(4,7,2,2)));
    root.right.right = new BuildNode(region(vec(4,4,0,0), vec(9,7,2,2)));

    root.left.isBuildNode.ngbrs = [
        BuildNode.Ngbr(root.right.right, region(vec(4,4,0,0), vec(8,4,1,1))),
    ];
    root.right.left.isBuildNode.ngbrs = [
        BuildNode.Ngbr(root.right.right, region(vec(4,4,0,0), vec(4,6,1,1))),
    ];
    root.right.right.isBuildNode.ngbrs = [
        BuildNode.Ngbr(root.left, region(vec(4,4,0,0), vec(8,4,1,1))),
        BuildNode.Ngbr(root.right.left, region(vec(4,4,0,0), vec(4,6,1,1))),
    ];

    genBackEdges(root, bounds, 1, 99);

    assert(root.left.isBuildNode.ngbrs[1].node is root.right.left);
    assert(root.left.isBuildNode.ngbrs[1].overlap ==
        region(vec(1,4,0,0), vec(3,4,1,1)));
    assert(root.right.left.isBuildNode.ngbrs[1].node is root.left);
    assert(root.right.left.isBuildNode.ngbrs[1].overlap ==
        region(vec(1,4,0,0), vec(3,4,1,1)));
}

/**
 * Returns: The minimum region of the given room node that covers all Doors.
 */
Region4 minCore(Region4 interior, Door[] doors)
    out(r; iota(4).all!(i => interior.min[i] <= r.min[i] &&
                             r.max[i] <= interior.max[i]))
{
    auto core = region(interior.max, interior.min);
    foreach (d; doors)
    {
        foreach (i; 0 .. 4)
        {
            if (i == d.axis)
            {
                if (core.min[i] > d.pos[i] + 1)
                    core.min[i] = d.pos[i] + 1;
                if (core.max[i] < d.pos[i])
                    core.max[i] = d.pos[i];
            }
            else
            {
                if (core.min[i] > d.pos[i])
                    core.min[i] = d.pos[i];
                if (core.max[i] < d.pos[i] + 1)
                    core.max[i] = d.pos[i] + 1;
            }
        }
    }
    return core;
}

unittest
{
    // Test case 1:
    //   012345
    // 0 ######
    // 1 -....#
    // 2 #....#
    // 3 #....#
    // 4 #....#
    // 5 ##-###
    auto r = region(vec(0,0,1,1), vec(1,1,5,5));
    auto doors = [
        Door(2, [0,0,0,1]),
        Door(3, [0,0,2,5]),
    ];

    assert(minCore(r, doors) == region(vec(0,0,1,1), vec(1,1,3,5)));

    // Test case 2:
    //   012345
    // 0 ######
    // 1 #....#
    // 2 #....#
    // 3 -....#
    // 4 #....#
    // 5 ##-###
    doors = [
        Door(2, [0,0,0,3]),
        Door(3, [0,0,2,5]),
    ];

    assert(minCore(r, doors) == region(vec(0,0,1,3), vec(1,1,3,5)));

    // Test case 3:
    //   012345
    // 0 ######
    // 1 #....#
    // 2 #....-
    // 3 #....#
    // 4 #....#
    // 5 ##-###
    doors = [
        Door(2, [0,0,5,2]),
        Door(3, [0,0,2,5]),
    ];

    assert(minCore(r, doors) == region(vec(0,0,2,2), vec(1,1,5,5)));

    // Test case 4:
    //   012345
    // 0 ###-##
    // 1 #....#
    // 2 #....-
    // 3 #....#
    // 4 #....#
    // 5 ######
    doors = [
        Door(2, [0,0,5,2]),
        Door(3, [0,0,3,0]),
    ];

    assert(minCore(r, doors) == region(vec(0,0,3,1), vec(1,1,5,3)));

    // Test case 5:
    //   012345
    // 0 ###-##
    // 1 #....#
    // 2 #....#
    // 3 #....#
    // 4 #....#
    // 5 ##-###
    doors = [
        Door(3, [0,0,3,0]),
        Door(3, [0,0,2,5]),
    ];

    assert(minCore(r, doors) == region(vec(0,0,2,1), vec(1,1,4,5)));

    // Test case 6:
    //   012345
    // 0 ###-##
    // 1 #....#
    // 2 -....#
    // 3 #....#
    // 4 #....#
    // 5 ######
    doors = [
        Door(2, [0,0,0,2]),
        Door(3, [0,0,3,0]),
    ];

    assert(minCore(r, doors) == region(vec(0,0,1,1), vec(1,1,4,3)));
}

/**
 * Iterate over leaf nodes in the given BSP tree and assign room interiors with
 * random sizes.
 *
 * Prerequisites: Initial (maximal) room interiors must have already been set.
 * Doors must have already been computed, since minimum room interior regions
 * are computed based on the position of doors.
 */
void resizeRooms(MapNode root, Region4 region, int minRoomDim)
{
    foreachRoom(root, region, (Region4 bounds, MapNode n) {
        import std.random : uniform;

        auto node = n.isRoom; // FIXME: this function should be a member of RoomNode
        if (node is null) return 0;

        // Find minimum region room must cover in order for exits to connect.
        auto core = minCore(node.interior, node.doors);

        // Expand minimum region to be at least (minRoomDim) tiles wide in each
        // direction.
        foreach (i; 0 .. 4)
        {
            if (node.interior.length(i) < minRoomDim)
                continue;   // FIXME: should be an error

            while (core.length(i) < minRoomDim)
            {
                if (uniform(0, 2) == 0)
                {
                    if (node.interior.min[i] < core.min[i])
                        core.min[i]--;
                }
                else
                {
                    if (core.max[i] < node.interior.max[i])
                        core.max[i]++;
                }
            }
        }

        // Select random size between bounding region and minimum region.
        Region4 result;
        foreach (i; 0 .. 4)
        {
            result.min[i] = uniform!"[]"(node.interior.min[i], core.min[i]);
            result.max[i] = uniform!"[]"(core.max[i], node.interior.max[i]);
        }

        node.interior = result;
        return 0;
    });
}

unittest
{
    // Test case: (base case)
    //   012345
    // 0 ####|#
    // 1 -    #
    // 2 #    -
    // 3 #|####
    auto bounds = region(vec(0,0,0,0), vec(6,4,2,2));
    auto root = new RoomNode;
    root.interior = region(vec(1,1,0,0), vec(5,3,1,1));
    root.doors = [
        Door(0, [0,1,0,0]),
        Door(1, [4,1,0,0]),
        Door(0, [5,2,0,0]),
        Door(1, [1,3,0,0]),
    ];

    resizeRooms(root, bounds, 3);

    assert(root.interior == region(vec(1,1,0,0), vec(5,3,1,1)));
}

/**
 * Returns: The coordinates of the "porch" of a particular door in the given
 * room, i.e., the tile next to the door that lies inside the interior of the
 * room.
 *
 * Prerequisites: The door must be part of the room, otherwise the result will
 * be nonsensical.
 */
Vec4 doorPorch(RoomNode room, Door d)
{
    auto result = vec(d.pos);
    result[d.axis] = result[d.axis].clamp(room.interior.min[d.axis],
                                          room.interior.max[d.axis]-1);
    return result;
}

unittest
{
    auto room = new RoomNode;
    room.interior = region(vec(1,1,1,1), vec(4,4,4,4));
    room.doors = [
        Door(0, [0,2,2,2]),
        Door(0, [4,1,1,1]),
        Door(1, [3,0,3,3]),
        Door(1, [3,4,3,3]),
    ];

    assert(doorPorch(room, room.doors[0]) == vec(1,2,2,2));
    assert(doorPorch(room, room.doors[1]) == vec(3,1,1,1));
    assert(doorPorch(room, room.doors[2]) == vec(3,1,3,3));
    assert(doorPorch(room, room.doors[3]) == vec(3,3,3,3));
}

/**
 * Create spiral stairs with the given top and winding parameters.
 */
void createSpiralStairs(World w, Vec4 top, Vec4 dx,
                        Vec4 dy, int bottom, bool thickenBelow)
{
    auto r = only(dx, dy, -dx, -dy).cycle;
    Vec4 v = top;
    while (++v[0] < bottom)
    {
        assert(!w.locationHas!BlocksMovement(v));
        createSpiralStep(&w.store, Pos(v),
                         (v[0]+1 < bottom) ? thickenBelow : false);
        v += r.front;
        r.popFront;
    }
}

bool tryAddSpiralStairs(World w, RoomNode room, Door d)
{
    // For now, build spiral stairs only for horizontal exits.
    if (d.axis == 0)
        return false;

    // Determine spiral 2-plane.
    int[2] axes;
    iota(1, 4).filter!(i => i != d.axis)
              .copy(axes[]);

    // Bounding box for stairwell.
    Region!(int,2) spiralBbox(Door d)
    {
        return region(vec(d.pos[axes[0]] - 1, d.pos[axes[1]] - 1),
                      vec(d.pos[axes[0]] + 1, d.pos[axes[1]] + 1));
    }
    auto bbox = spiralBbox(d);

    // Check for overlap with other doors' bounding boxes.
    auto porch = doorPorch(room, d);
    foreach (dd; room.doors)
    {
        if (d == dd) continue;
        auto porch2 = doorPorch(room, dd);
        if (porch2[d.axis] != porch[d.axis])
            continue;

        if (spiralBbox(dd).intersects(bbox))
            return false;
    }

    // Construct basis vectors for winding the stairs.
    Vec4[2] basis;
    foreach (i; 0 .. 2)
    {
        auto axis = axes[i];
        basis[i][axis] = only(-1, 1)
            .filter!(x => porch[axis] + x >= room.interior.min[axis] &&
                          porch[axis] + x < room.interior.max[axis])
            .pickOne;
    }

    createSpiralStairs(w, porch, basis[0], basis[1], room.interior.max[0],
                       true);

    return true;
}

/**
 * Generate ladders for reaching doors that are too high to reach from floor.
 *
 * Prerequisites: Room interiors must already have been set.
 */
void addLadders(World w, MapNode tree, Region4 bounds, int spiralPct)
{
    foreachRoom(tree, bounds, (Region4 bounds, MapNode n) {
        auto node = n.isRoom;
        if (node is null) return 0;
        foreach (d; node.doors)
        {
            if (d.axis == 0 && d.type == Door.Type.normal &&
                d.pos[0] < node.interior.min[0])
            {
                // Vertical exits
                foreach (i; d.pos[0] .. node.interior.max[0])
                {
                    createLadder(&w.store, Pos(i, d.pos[1], d.pos[2],
                                               d.pos[3]));
                }
            }
            else if (d.axis != 0 && d.pos[0] < node.interior.max[0] - 2)
            {
                // Horizontal exits

                // Adjusted down from 100% based on statistical likelihood
                // tryAddSpiralStairs will fail, as measured by level gen
                // stress tests.
                enum adjPct = 81;
                if (uniform(0, adjPct) < spiralPct &&
                    tryAddSpiralStairs(w, node, d))
                {
                    continue;
                }

                auto pos = d.pos;
                pos[d.axis] = (d.pos[d.axis] == node.interior.max[d.axis]) ?
                              d.pos[d.axis] - 1 : d.pos[d.axis] + 1;
                foreach (i; d.pos[0] + 1 .. node.interior.max[0])
                {
                    createLadder(&w.store, Pos(i, pos[1], pos[2], pos[3]));
                }
            }
        }
        return 0;
    });
}

unittest
{
    import gamemap, terrain;

    // Test map:
    //    0123456
    //  0 ###=###
    //  1 #  =  #
    //  2 |_ =  #
    //  3 #= =  |
    //  4 #= =  #
    //  5 #######
    auto root = new RoomNode;
    root.interior = Region4(vec(1,1,1,1), vec(5,6,2,2));
    root.doors ~= Door(1, [2,0,1,1], Door.Type.normal);
    root.doors ~= Door(0, [0,3,1,1], Door.Type.normal);
    root.doors ~= Door(1, [3,6,1,1], Door.Type.normal);

    auto w = new World;
    w.map.tree = root;

    // Ladder placement should use interior, not bounding region.
    w.map.bounds = region(vec(0,0,0,0), vec(9,9,9,9));

    w.map.waterLevel = int.max;

    addLadders(w, w.map.tree.isRoom, w.map.bounds, 0);

    bool hasLadder(Pos pos)
    {
        return w.getAllAt(pos)
                .canFind!(id => w.store.get!Tiled(id).tileId == TileId.ladder);
    }

    assert(!hasLadder(Pos(0,1,1,1)));
    assert(!hasLadder(Pos(1,1,1,1)));
    assert(!hasLadder(Pos(2,1,1,1)));
    assert( hasLadder(Pos(3,1,1,1)));
    assert( hasLadder(Pos(4,1,1,1)));
    assert(!hasLadder(Pos(5,1,1,1)));

    assert( hasLadder(Pos(0,3,1,1)));
    assert( hasLadder(Pos(1,3,1,1)));
    assert( hasLadder(Pos(2,3,1,1)));
    assert( hasLadder(Pos(3,3,1,1)));
    assert( hasLadder(Pos(4,3,1,1)));
    assert(!hasLadder(Pos(5,3,1,1)));

    assert(!hasLadder(Pos(0,5,1,1)));
    assert(!hasLadder(Pos(1,5,1,1)));
    assert(!hasLadder(Pos(2,5,1,1)));
    assert(!hasLadder(Pos(3,5,1,1)));
    assert(!hasLadder(Pos(4,5,1,1)));
    assert(!hasLadder(Pos(5,5,1,1)));
}

unittest
{
    import gamemap, terrain;

    // Test map:
    //    0123456
    //  0 ###=###
    //  1 #  =  #
    //  2 #  = _|
    //  3 |  = =#
    //  4 #  = =#
    //  5 #######
    auto root = new RoomNode;
    root.interior = Region4(vec(1,1,1,1), vec(5,6,2,2));
    root.doors ~= Door(1, [3,0,1,1], Door.Type.normal);
    root.doors ~= Door(0, [0,3,1,1], Door.Type.normal);
    root.doors ~= Door(1, [2,6,1,1], Door.Type.normal);

    auto w = new World;
    w.map.tree = root;

    // Ladder placement should use interior, not bounding region.
    w.map.bounds = region(vec(0,0,0,0), vec(9,9,9,9));

    w.map.waterLevel = int.max;

    addLadders(w, w.map.tree.isRoom, w.map.bounds, 0);

    bool hasLadder(Pos pos)
    {
        return w.getAllAt(pos)
                .canFind!(id => w.store.get!Tiled(id).tileId == TileId.ladder);
    }

    assert(!hasLadder(Pos(0,1,1,1)));
    assert(!hasLadder(Pos(1,1,1,1)));
    assert(!hasLadder(Pos(2,1,1,1)));
    assert(!hasLadder(Pos(3,1,1,1)));
    assert(!hasLadder(Pos(4,1,1,1)));
    assert(!hasLadder(Pos(5,1,1,1)));

    assert( hasLadder(Pos(0,3,1,1)));
    assert( hasLadder(Pos(1,3,1,1)));
    assert( hasLadder(Pos(2,3,1,1)));
    assert( hasLadder(Pos(3,3,1,1)));
    assert( hasLadder(Pos(4,3,1,1)));
    assert(!hasLadder(Pos(5,3,1,1)));

    assert(!hasLadder(Pos(0,5,1,1)));
    assert(!hasLadder(Pos(1,5,1,1)));
    assert(!hasLadder(Pos(2,5,1,1)));
    assert( hasLadder(Pos(3,5,1,1)));
    assert( hasLadder(Pos(4,5,1,1)));
    assert(!hasLadder(Pos(5,5,1,1)));
}

/**
 * Randomly assign room floors.
 */
void setRoomFloors(MapNode root, Region4 bounds)
{
    foreachRoom(root, bounds, (Region4 r, MapNode n) {
        import std.random : uniform;
        auto node = n.isRoom; // FIXME
        if (node is null) return 0;
        auto x = uniform(0, 100);
        node.style = (x < 50) ? FloorStyle.bare :
                     (x < 80) ? FloorStyle.grassy :
                                FloorStyle.muddy;
        return 0;
    });
}

version(none)
unittest
{
    import testutil;
    enum wd = 48, ht = 24;
    auto result = TestScreen!(wd,ht)();

    import std.algorithm : filter, clamp;
    import std.random : uniform;
    import std.range : iota;
    import rndutil;

    // Generate base BSP tree
    auto bounds = region(vec(1, 1, 0, 0), vec(wd, ht, 2, 2));

    auto tree = genBsp!(MapNode, RoomNode)(bounds,
        (Region4 r) => r.length(0)*r.length(1) > 49 + uniform(0, 50),
        (Region4 r) => iota(4).filter!(i => r.max[i] - r.min[i] > 8)
                        .pickOne(invalidAxis),
        (Region4 r, int axis) => (r.max[axis] - r.min[axis] < 8) ?
            invalidPivot : uniform(r.min[axis]+4, r.max[axis]-3)
            //gaussian(r.max[axis] - r.min[axis], 4)
            //    .clamp(r.min[axis] + 3, r.max[axis] - 3)
    );

    auto w = new World;
    w.map.tree = tree;
    w.map.bounds = bounds;

    // Generate connecting corridors
    setRoomInteriors(w.map.tree, w.map.bounds);
    genCorridors(w.map.tree, w.map.bounds);
    assert(doorsSanityCheck(w));

    // Generate back edges
    genBackEdges(w.map.tree, w.map.bounds, 4, 15,
        (in RoomNode[2] rooms, ref Door d) {
            d.type = Door.Type.extra;
            return true;
        },
        (MapNode node, Region4 region) => uniform(0, 2), false
    );
    assert(doorsSanityCheck(w));

    resizeRooms(w.map.tree, w.map.bounds, 3);
    assert(doorsSanityCheck(w));

    setRoomFloors(w.map.tree, w.map.bounds);

    version(none)
    {
        dumpBsp(result, w.map.tree, w.map.bounds);
        assert(0);
    }
}

version(none)
unittest
{
    import testutil;
    enum wd = 20, ht = 12;
    auto result = TestScreen!(wd,ht)();

    import std.algorithm : filter, clamp;
    import std.random : uniform;
    import std.range : iota;
    import rndutil;

    // Generate base BSP tree
    auto bounds = region(vec(1, 1, 0, 0), vec(wd, ht, 2, 2));

    TreeGenArgs args;
    args.splitVolume = ValRange(50, 200);
    args.minNodeDim = 2;
    auto tree = genTree(bounds, args);

    auto w = new World;
    w.map.tree = tree;
    w.map.bounds = bounds;
    assert(doorsSanityCheck(w));

    // Generate back edges
    genBackEdges(w.map.tree, w.map.bounds, 4, 15,
        (in RoomNode[2] rooms, ref Door d) {
            d.type = Door.Type.extra;
            return true;
        },
        (MapNode node, Region4 region) => uniform(0, 2), false
    );
    assert(doorsSanityCheck(w));

    resizeRooms(w.map.tree, w.map.bounds, args.minNodeDim-1);
    assert(doorsSanityCheck(w));

    setRoomFloors(w.map.tree, w.map.bounds);

    version(none)
    {
        dumpBsp(result, w.map.tree, w.map.bounds);
        assert(0);
    }
}

private int roomMetric()(MapNode node, Distrib distrib)
{
    final switch (distrib)
    {
        case Distrib.tree:      return 1;
        case Distrib.floor:     return node.floorArea;
        case Distrib.volume:    return node.volume;
    }
}

/**
 * Returns: A randomly selected leaf node in the given BSP tree according to
 * the specified distribution.
 */
MapNode randomRoom(MapNode tree, Distrib distrib)
{
    MapNode pickNode(MapNode node)
    {
        if (node.isLeaf)
            return node;

        auto m1 = roomMetric(node.left, distrib);
        auto m2 = roomMetric(node.right, distrib);
        auto choice = (uniform(0, m1 + m2) < m1) ? node.left : node.right;
        return pickNode(choice);
    }

    return pickNode(tree);
}

/// ditto
Tuple!(MapNode,Region4) randomRoom(MapNode tree, Region4 bounds,
                                   Distrib distrib)
{
    Tuple!(MapNode,Region4) pickNode(MapNode node,
                                            Region4 bounds)
    {
        if (node.isLeaf)
            return tuple(node, bounds);

        auto m1 = roomMetric(node.left, distrib);
        auto m2 = roomMetric(node.right, distrib);
        if (uniform(0, m1 + m2) < m1)
            return pickNode(node.left, leftRegion(bounds, node.axis,
                                                  node.pivot));
        else
            return pickNode(node.right, rightRegion(bounds, node.axis,
                                                    node.pivot));
    }

    return pickNode(tree, bounds);
}

/**
 * Returns: A uniformly randomly selected location from the map satisfying the
 * given filter, or a null node if no such location could be found within the
 * specified number of attempts.
 *
 * FIXME: This needs to be refactored into the derived classes of MapNode.
 */
Tuple!(MapNode, Vec4) randomRoomPos(World w, MapNode tree,
                                           RandomPosFilt filt)
{
    foreach (nTries; 0 .. filt.maxTries)
    {
        auto node = randomRoom(tree, filt.distrib);
        auto loc = node.randomLoc((filt.support == Support.below ||
                                   filt.distrib == Distrib.floor));

        final switch (filt.dryness)
        {
            case Dryness.any:
                break;

            case Dryness.dry:
                if (loc[0] >= w.map.waterLevel)
                    continue;
                break;

            case Dryness.wet:
                if (loc[0] < w.map.waterLevel)
                    continue;
                break;
        }

        final switch (filt.occupancy)
        {
            case Occupancy.any:
                break;

            case Occupancy.empty:
                if (w.store.getAllBy!Pos(Pos(loc)).length > 0)
                    continue;
                break;
            case Occupancy.occupied:
                if (w.store.getAllBy!Pos(Pos(loc)).length == 0)
                    continue;
                break;
        }

        final switch (filt.support)
        {
            case Support.any:
                break;

            case Support.below:
                auto floorPos = loc + vec(1,0,0,0);
                if (!w.locationHas!BlocksMovement(floorPos))
                    continue;
                break;
        }

        if (filt.extraFilt !is null && !filt.extraFilt(node, loc))
            continue;

        return tuple(cast(MapNode) node, loc);
    }

    return typeof(return).init;
}

/// ditto
Vec4 randomPos(World w, MapNode tree, RandomPosFilt filt)
{
    auto roomPos = randomRoomPos(w, tree, filt);
    if (roomPos[0] is null)
    {
        import std.format : format;
        throw new Exception("Unable to find random pos satisfying: %s"
                            .format(filt));
    }
    return roomPos[1];
}

unittest
{
    auto bounds = region(vec(0,0,0,0), vec(10,5,5,5));
    auto root = new MapNode;
    root.axis = 0;
    root.pivot = 5;

    root.left = new RoomNode;
    root.left.isRoom.interior = region(vec(0,0,0,0), vec(4,4,4,4));

    root.right = new RoomNode;
    root.right.isRoom.interior = region(vec(5,0,0,0), vec(9,4,4,4));

    auto w = new World;
    w.map.tree = root;
    w.map.bounds = bounds;

    auto filt = RandomPosFilt(Dryness.dry, Occupancy.any, Support.any,
                              Distrib.floor, null, 10);

    w.map.waterLevel = 8;
    assert(randomRoomPos(w, root, filt)[0] is root.left);

    w.map.waterLevel = 5;
    assert(randomRoomPos(w, root, filt)[0] is root.left);

    w.map.waterLevel = 4;
    assert(randomRoomPos(w, root, filt)[0] is root.left);

    w.map.waterLevel = 3;
    assert(randomRoomPos(w, root, filt)[0] is null);
}

unittest
{
    auto bounds = region(vec(0,0,0,0), vec(10,5,5,5));
    auto root = new MapNode;
    root.axis = 0;
    root.pivot = 5;

    root.left = new RoomNode;
    root.left.isRoom.interior = region(vec(0,0,0,0), vec(4,4,4,4));

    root.right = new RoomNode;
    root.right.isRoom.interior = region(vec(5,0,0,0), vec(9,4,4,4));

    auto w = new World;
    w.map.tree = root;
    w.map.bounds = bounds;
    w.map.waterLevel = 7;

    auto pos = randomPos(w, root, RandomPosFilt(Dryness.dry, Occupancy.any,
                                                Support.any, Distrib.floor,
                                                null, 10));
    assert(root.left.isRoom.interior.contains(pos));
}

/**
 * Generate pits and pit traps.
 *
 * Params:
 *  w = The game world.
 *  count = The number of pit traps to attempt to place. Note that the actual
 *      number of traps generated may be lower than this, if there are too many
 *      failed attempts to find suitable locations for traps.
 *  openPitPct = Percentage of pits that will be visible open pits, vs. hidden
 *      traps.
 */
void genPitTraps(World w, MapNode tree, Region4 bounds, int count,
                 int openPitPct = 30)
{
version(none)
    genBackEdges(tree, bounds, count, count*8,
        (in RoomNode[2] rooms, ref Door d) {
            assert(d.axis == 0);

            bool nextToExisting;
            foreach (rm; rooms)
            {
                foreach (dd; rm.doors)
                {
                    if (dd.type == Door.Type.normal &&
                        iota(4).map!(i => abs(d.pos[i] - dd.pos[i])).sum == 1)
                    {
                        nextToExisting = true;
                    }

                    if (dd.axis != 0 &&
                        iota(1, 4).map!(i => abs(d.pos[i] - dd.pos[i]))
                                  .sum == 1)
                    {
                        // Don't place where a ladder would be placed.
                        return false;
                    }
                }
            }

            if (!nextToExisting && uniform(0, 100) < openPitPct)
            {
                // Non-hidden open pit.
                d.type = Door.Type.extra;
            }
            else
            {
                d.type = Door.Type.trapdoor;
                auto floorId = style2Terrain(rooms[0].style);
                w.store.createObj(Pos(vec(d.pos) + vec(-1,0,0,0)),
                                  Trigger(Trigger.Type.onEnter, w.triggerId));
                w.store.createObj(Pos(d.pos), Name("pit trap"),
                    Tiled(TileId.wall, -1), *w.store.get!TiledAbove(floorId),
                    BlocksMovement(Climbable.yes), BlocksView(),
                    Triggerable(w.triggerId, TriggerEffect.trapDoor),
                    SupportsWeight(SupportType.above));
                w.triggerId++;
            }
            return true;
        },
        (MapNode node, Region4 bounds) => 0, // always pick vertical
        true,   // allow multiple pit traps on same wall as normal door
    );
}

unittest
{
    // Test case:
    //   01234
    // 0 #####
    // 1 #   #
    // 2 ##X##
    // 3 #   #
    // 4 #   #
    // 5 #####
    auto bounds = region(vec(0,0,0,0), vec(6,5,2,2));
    auto root = new MapNode;
    root.axis = 0;
    root.pivot = 3;

    root.left = new RoomNode;
    root.left.isRoom.interior = region(vec(1,1,0,0), vec(2,4,1,1));
    root.left.isRoom.style = FloorStyle.grassy;

    root.right = new RoomNode;
    root.right.isRoom.interior = region(vec(3,1,0,0), vec(5,4,1,1));
    root.right.isRoom.style = FloorStyle.muddy;

    auto w = new World;
    w.map.tree = root;
    w.map.bounds = bounds;

    genPitTraps(w, root, bounds, 1, 0);

    auto r = w.store.getAll!Triggerable()
                    .map!(id => w.store.get!TiledAbove(id));
    assert(!r.empty);
    assert(r.front.tileId == TileId.floorGrassy);
}

/**
 * Generate rock traps.
 *
 * Prerequisites:
 * - Must be called *after resizeRooms(), addLadders(), setting of water
 *   levels, and placement of important level objects like portals, because
 *   this will generate traps on any unoccupied floor tile. (But it's probably
 *   OK to call this before placing gold, monsters, or other items: it will
 *   just be trapped gold. :-P)
 *
 * Note: this is done separately from genPitTraps because it needs rooms'
 * .interior to be already fixed.
 *
 * BUGS: Unfortunately, this function is not 100% World-agnostic; it requires
 * w.map to be initialized otherwise it will crash.
 */
void genRockTraps(World w, MapNode tree, Region4 bounds, int count)
{
    auto filt = RandomPosFilt(Dryness.dry, Occupancy.empty, Support.any,
                              Distrib.floor);
    filt.extraFilt = (MapNode node, int[4] pos) {
        auto room = node.isRoom; // FIXME
        if (room is null) return false;
        return !room.doors.canFind!(d => iota(1, 4)
                                        .map!(i => abs(d.pos[i] - pos[i]))
                                                    .sum <= 1);
    };

    OUTER: for (; count > 0; count--)
    {
        auto roomPos = randomRoomPos(w, tree, filt);
        auto room = roomPos[0].isRoom;
        auto pos = roomPos[1];

        if (room is null) continue;

        auto ceilingPos = pos;
        ceilingPos[0] = room.interior.min[0];
        pos[0] = room.interior.max[0] - 1;

        createRockTrapTrig(&w.store, pos, w.triggerId);
        createRockTrap(&w.store, ceilingPos, w.triggerId);
        w.triggerId++;
    }
}

unittest
{
    // Unfortunately this is probabilistic; so to catch potential violations we
    // need to repeat it a few times.
    foreach (_; 0 .. 5)
    {
        // Room plan:
        //          0       1       2       3
        //          0123    0123    0123    0123
        // 0   0    ####    ####    ####    ####
        //     1    ####    ####    #-##    ####
        //     2    ####    ####    ####    ####
        //     3    ####    ####    ####    ####
        //
        //          0123    0123    0123    0123
        // 1   0    ####    #-##    ####    ####
        //     1    ####    #  #    #= #    ####
        //     2    ####    # !#    #  #    ####
        //     3    ####    ####    ####    ####
        //
        //          0123    0123    0123    0123
        // 2   0    ####    ####    ####    ####
        //     1    ####    #..-    #=.#    ####
        //     2    ####    -.^#    #..#    #-##
        //     3    ####    ####    ####    ####
        auto root = new RoomNode;
        root.interior = region(vec(1,1,1,1), vec(3,3,3,3));
        root.doors = [
            Door(2, [1,1,0,1]),
            Door(3, [2,1,2,0]),
            Door(3, [2,1,1,3]),
            Door(0, [0,2,1,1]),
            Door(1, [2,3,2,1]),
        ];

        auto w = new World;
        w.map.tree = root;
        w.map.bounds = region(vec(0,0,0,0), vec(4,4,4,4));
        w.map.waterLevel = int.max;

        w.store.createObj(Pos(2,2,1,2), Name("blocker"));
        w.store.createObj(Pos(2,2,2,2), Name("blocker"));

        while (w.triggerId < 1)
            genRockTraps(w, w.map.tree, w.map.bounds, 1);

        import std.format : format;
        auto r = w.store.getAll!Triggerable()
                        .map!(id => w.store.get!Pos(id));
        assert(!r.empty);
        assert(r.front !is null && *r.front == Pos(1,1,2,2),
               format("%s", *r.front));
    }
}

/**
 * Locates the neighbour of the given node connected by the given door.
 */
RoomNode findNgbr(MapNode tree, Region4 bounds, RoomNode node, uint doorIdx)
    in (doorIdx < node.doors.length)
{
    // Compute coordinates of the other side of the door.
    auto d = node.doors[doorIdx];
    auto otherSide = vec(d.pos);
    otherSide[d.axis] += (d.pos[d.axis] == node.interior.max[d.axis]) ? 1 : -1;

    RoomNode ngbr;
    Region4 ngbrBounds;
    foreachFiltRoom(tree, bounds, (Region4 r) => r.contains(otherSide),
                    (MapNode n, Region4 r1) {
                        assert(ngbr is null);
                        auto room = n.isRoom;
                        if (room is null) return 0;
                        ngbr = room;
                        ngbrBounds = r1;
                        return 1;
                    });

    return ngbr;
}

unittest
{
    //   0123456789
    // 0 ##########
    // 1 #   #    #
    // 2 #   #    #
    // 3 ##|##    #
    // 4 #   -    #
    // 5 #   #    #
    // 6 ##########
    auto root = new MapNode;
    root.axis = 2;
    root.pivot = 5;

    root.left = new MapNode;
    root.left.axis = 3;
    root.left.pivot = 4;
    root.left.left = new RoomNode;
    root.left.left.isRoom.doors ~= Door(3, [ 1, 1, 2, 3 ]);
    root.left.right = new RoomNode;
    root.left.right.isRoom.doors ~= Door(3, [ 1, 1, 2, 3 ]);
    root.left.right.isRoom.doors ~= Door(2, [ 1, 1, 4, 4 ]);

    root.right = new RoomNode;
    root.right.isRoom.doors ~= Door(2, [ 1, 1, 4, 4 ]);

    auto bounds = region(vec(0,0,1,1), vec(2,2,10,7));
    setRoomInteriors(root, bounds);

    assert(findNgbr(root, bounds, root.right.isRoom, 0) == root.left.right);
    assert(findNgbr(root, bounds, root.left.right.isRoom, 0) == root.left.left);
    assert(findNgbr(root, bounds, root.left.right.isRoom, 1) == root.right);
    assert(findNgbr(root, bounds, root.left.left.isRoom, 0) == root.left.right);
}

/**
 * Adjusts doors heights to be flush against the highest floor they connect, so
 * that we avoid unnecessary ladders.
 */
void sinkDoors(MapNode tree, Region4 region)
{
    foreachRoom(tree, region, (Region4 bounds, MapNode n)
    {
        auto node = n.isRoom;
        if (node is null) return 0; // FIXME

        foreach (i, ref d; node.doors)
        {
            if (d.axis == 0) continue;
            auto ngbr = findNgbr(tree, region, node, cast(uint) i);
            if (ngbr is null) continue;
            auto upperFloor = min(node.interior.max[0], ngbr.interior.max[0]);
            d.pos[0] = upperFloor - 1;
        }
        return 0;
    });
}

unittest
{
    //   0123456789
    // 0 ##########
    // 1 #3  #4   #
    // 2 #   #    #
    // 3 ##|##    #
    // 4 #5  -    #
    // 5 #   #    #
    // 6 ##########
    auto root = new MapNode;
    root.axis = 2;
    root.pivot = 5;

    root.left = new MapNode;
    root.left.axis = 3;
    root.left.pivot = 4;
    root.left.left = new RoomNode;
    root.left.left.isRoom.doors ~= Door(3, [ 1, 1, 2, 3 ]);
    root.left.right = new RoomNode;
    root.left.right.isRoom.doors ~= Door(3, [ 1, 1, 2, 3 ]);
    root.left.right.isRoom.doors ~= Door(2, [ 1, 1, 4, 4 ]);

    root.right = new RoomNode;
    root.right.isRoom.doors ~= Door(2, [ 1, 1, 4, 4 ]);

    auto bounds = region(vec(0,0,1,1), vec(5,2,10,7));
    setRoomInteriors(root, bounds);

    // Set floor heights
    root.left.left.isRoom.interior.max[0] = 3;
    root.left.right.isRoom.interior.max[0] = 5;
    root.right.isRoom.interior.max[0] = 4;

    auto w = new World;
    w.map.tree = root;
    w.map.bounds = bounds;

    sinkDoors(w.map.tree, w.map.bounds);

    assert(root.left.left.isRoom.doors == [
        Door(3, [ 2, 1, 2, 3 ]),
    ]);
    assert(root.left.right.isRoom.doors == [
        Door(3, [ 2, 1, 2, 3 ]),
        Door(2, [ 3, 1, 4, 4 ]),
    ]);
    assert(root.right.isRoom.doors == [
        Door(2, [ 3, 1, 4, 4 ]),
    ]);
}

/**
 * Places an exit portal.
 */
void genPortal(World w, MapNode tree, Region4 bounds)
{
    // Pick a tile that isn't empty or has no floor support.
    auto pos = randomPos(w, tree, RandomPosFilt(Dryness.dry, Occupancy.empty,
                                                Support.below, Distrib.floor));
    createPortal(&w.store, pos);
}

unittest
{
    auto node = new RoomNode;
    node.interior = region(vec(0,0,0,0), vec(2,2,1,1));
    node.doors = [ Door(0, [2,0,0,0], Door.Type.trapdoor) ];

    auto w = new World;
    w.map.tree = node;
    w.map.bounds = region(vec(0,0,0,0), vec(3,3,2,2));
    w.map.waterLevel = int.max;

    foreach (_; 0 .. 10)
    {
        genPortal(w, w.map.tree, w.map.bounds);

        auto r = w.store.getAll!Usable();
        assert(!r.empty);
        auto id = r.front;
        auto pos = *w.store.get!Pos(id);
        assert(pos == Pos(1,1,0,0));

        r.popFront;
        assert(r.empty);

        w.store.destroyObj(id);
    }
}

/**
 * A random variable bounded by a range.
 */
struct ValRange
{
    int min, max=1;
    int pick() { return uniform(min, max); }

    unittest
    {
        ValRange v;
        assert(v.pick == 0);
    }
}

/**
 * Map generation parameters.
 */
struct TreeGenArgs
{
    /**
     * Nodes with this volume or greater will be considered for splitting.
     *
     * Note that the ValRange is evaluated once per node; so the lower bound
     * essentially acts as a minimum volume before a node will be split, and
     * the upper bound gives a probability of when a large node up to that size
     * will not be split.
     */
    ValRange splitVolume = ValRange(25, 105);

    /**
     * Minimum length of a node along each axis. A candidate split will be
     * rejected if it would result in a node that has a dimension smaller than
     * this length.  This effectively means nodes of less than 2*minNodeDim
     * along an axis would not be split along that axis (its other axes may
     * still split, though).
     *
     * Note that this must also include space for walls if the node is to be
     * made into a room; so this value should be ≥2 (which would result in a
     * narrow corridor), or ≥3 if narrow corridors are not wanted.
     */
    int minNodeDim = 4;
}

struct MapGenArgs
{
    TreeGenArgs tree;
    ValRange nBackEdges;
    ValRange nPitTraps;
    ValRange nRockTraps;
    int spiralStairsPct = 5;

    float goldPct;
    float rockPct = 2.0, sharpRockPct = 5.0;
    ValRange waterLevel = ValRange(int.max-1, int.max);
    ValRange nMonstersA;
    ValRange nMonstersB;
    ValRange nMonstersC;
    ValRange nCrabShells;
    ValRange nScubas;

    bool sinkDoors = true;
}

/**
 * Generate raw level geometry.
 *
 * NOTE: May return null if bounds are too small to generate geometry that
 * satisfies map constraints.
 */
MapNode genTree(Region4 bounds, TreeGenArgs args)
{
    enum nRetries = 10;
    auto splitLen = args.minNodeDim * 2;

    MapNode tree;
    foreach (_; 0 .. nRetries)
    {
        // FIXME: should generate more than just RoomNode.
        tree = genBsp!(MapNode, BuildNode)(bounds,
            (Region4 r) => r.volume > args.splitVolume.pick,
            (Region4 r) => iota(4).filter!(i => r.max[i] - r.min[i] >= splitLen)
                                  .pickOne(invalidAxis),
            (Region4 r, int axis) => (r.max[axis] - r.min[axis] < splitLen) ?
                invalidPivot : uniform(r.min[axis] + args.minNodeDim,
                                       r.max[axis] - args.minNodeDim + 1)
        );

        //setRoomInteriors(tree, bounds);
        try
        {
            genCorridors(tree, bounds);
            break;
        }
        catch (GenCorridorsException e)
        {
            // This tree can't be properly connected; try again with a
            // different tree.
            tree = null;
            //version(none)
            {
                import std.stdio;
                writefln("genCorridors failed (%s), retrying", e.msg);
            }
        }
    }

    return tree;
}

/**
 * Phase 2 of level geometry generation.
 */
void genGeometry(World w, MapNode tree, Region4 bounds, MapGenArgs args)
{
    setRoomFloors(tree, bounds);

    // Add back edges, regular and pits/pit traps.
    genBackEdges(tree, bounds, args.nBackEdges.pick,
                 args.nBackEdges.max + 15);
    genPitTraps(w, tree, bounds, args.nPitTraps.pick);

    resizeRooms(tree, bounds, args.tree.minNodeDim - 1);
    if (args.sinkDoors)
        sinkDoors(tree, bounds);
}

void genObjects(World w, MapNode tree, Region4 bounds, MapGenArgs args,
                MapNode startRoom = null)
{
    addLadders(w, tree, bounds, args.spiralStairsPct);
    genRockTraps(w, tree, bounds, args.nRockTraps.pick);

    // Items
    foreach (i; 0 .. args.nCrabShells.pick())
    {
        auto pos = randomPos(w, tree, RandomPosFilt(Dryness.any,
                                                    Occupancy.empty,
                                                    Support.below,
                                                    Distrib.floor));
        createCrabShell(&w.store, Pos(pos));
    }

    foreach (i; 0 .. args.nScubas.pick())
    {
        auto pos = randomPos(w, tree, RandomPosFilt(Dryness.dry,
                                                    Occupancy.empty,
                                                    Support.below,
                                                    Distrib.floor));
        createScuba(&w.store, Pos(pos));
    }

    // Generate random rocks as additional deco.
    auto mapFloorArea = tree.floorArea;
    foreach (i; 0 .. mapFloorArea * args.rockPct / 100)
    {
        auto pos = randomPos(w, tree, RandomPosFilt(Dryness.any,
                                                    Occupancy.empty,
                                                    Support.below,
                                                    Distrib.floor));
        if (uniform(0, 100) < args.sharpRockPct)
            createSharpRock(&w.store, Pos(pos));
        else
            createRock(&w.store, Pos(pos));
    }

    // Generate random vegetation for creatures to seek out once in a while.
    enum vegPct = 8; // FIXME: should be configurable
    enum vegDensePct = 15;
    foreach (i; 0 .. mapFloorArea * vegPct / 100)
    {
        // TBD: bias the distribution to be closer to water line, fade away
        // farther away from water line.
        auto pos = randomPos(w, tree, RandomPosFilt(Dryness.any,
                                                    Occupancy.empty,
                                                    Support.below,
                                                    Distrib.floor));
        if (uniform(0, 100) < vegDensePct)
            createDenseVeg(&w.store, Pos(pos));
        else
            createVeg(&w.store, Pos(pos));
    }

    // Note: this should be done after all other items / deco, so that it
    // doesn't get obscured!
    auto ngold = cast(int)(mapFloorArea * args.goldPct / 100);
    foreach (i; 0 .. ngold)
    {
        auto filt = RandomPosFilt(Dryness.any, Occupancy.empty, Support.below,
                                  Distrib.floor);
        createGold(&w.store, Pos(randomPos(w, tree, filt)));
    }

    foreach (i; 0 .. args.nMonstersA.pick())
    {
        auto filt = RandomPosFilt(Dryness.dry, Occupancy.empty, Support.below,
                                  Distrib.floor);
        filt.extraFilt = (MapNode room, int[4] pos) => room !is startRoom;
        auto pos = randomPos(w, tree, filt);
        createMonsterA(&w.store, Pos(pos));
    }

    foreach (i; 0 .. args.nMonstersB.pick())
    {
        auto filt = RandomPosFilt(Dryness.wet, Occupancy.empty, Support.any,
                                  Distrib.volume);
        filt.extraFilt = (MapNode room, int[4] pos) => room !is startRoom;
        auto pos = randomPos(w, tree, filt);

        createMonsterB(&w.store, Pos(pos));
    }

    foreach (i; 0 .. args.nMonstersC.pick())
    {
        auto filt = RandomPosFilt(Dryness.any, Occupancy.empty, Support.below,
                                  Distrib.floor);
        filt.extraFilt = (MapNode room, int[4] pos) => room !is startRoom;
        auto pos = randomPos(w, tree, filt);

        createMonsterC(&w.store, Pos(pos));
    }
}

/**
 * Generate new game world using the BSP tree algorithm.
 */
World genBspLevel(Region4 bounds, MapGenArgs args, out int[4] startPos)
{
    auto w = new World;

    // Generate level geometry
    w.map.waterLevel = args.waterLevel.pick;
    w.map.tree = genTree(bounds, args.tree);
    if (w.map.tree is null)
        throw new Exception("Unable to generate map");
    w.map.bounds = bounds;
    genGeometry(w, w.map.tree, bounds, args);

    // Place starting position and exit.
    auto roomPos = randomRoomPos(w, w.map.tree,
                                 RandomPosFilt(Dryness.dry, Occupancy.empty,
                                               Support.below, Distrib.floor));
    auto startRoom = roomPos[0];
    startPos = roomPos[1];
    genPortal(w, w.map.tree, w.map.bounds);

    // Add objects and deco.
    genObjects(w, w.map.tree, w.map.bounds, args, startRoom);

    return w;
}

// Mapgen sanity tests.
unittest
{
    foreach (i; 0 .. 12)
    {
        int[4] startPos;
        MapGenArgs args;
        auto bounds = region(vec(0,0,0,0), vec(10,10,10,10));
        auto w = genBspLevel(bounds, args, startPos);

        // Door placement checks.
        foreachRoom(w.map.tree, w.map.bounds,
            (Region4 region, MapNode n) {
                auto node = n.isRoom;
                if (node is null) return 0;
                foreach (i; 0 .. node.doors.length-1)
                {
                    auto d1 = node.doors[i];
                    auto pos1 = d1.pos;
                    foreach (j; i+1 .. node.doors.length)
                    {
                        auto d2 = node.doors[j];
                        auto pos2 = d2.pos;

                        // No coincident doors.
                        assert(pos1 != pos2);

                        // Only trapdoors/pits are allowed to be adjacent to
                        // another door.
                        if (iota(4).map!(i => abs(pos1[i] - pos2[i])).sum == 1)
                        {
                            assert(d1.type != Door.Type.normal ||
                                   d2.type != Door.Type.normal);
                        }
                    }

                    // Trapdoors & pits not allowed where ladders would be
                    // placed.
                    if (d1.type != Door.Type.normal)
                    {
                        foreach (j; 0 .. node.doors.length)
                        {
                            auto d2 = node.doors[j];
                            auto pos2 = d2.pos;

                            if (i == j || d2.axis == 0)
                                continue;

                            assert(iota(1,4).map!(i => abs(pos1[i] - pos2[i]))
                                            .sum != 1);
                        }
                    }
                }
                return 0;
            }
        );

        // Water level tests.
        import std.format : format;
        assert(startPos[0] < w.map.waterLevel,
               format("startPos %s below water level %d", startPos,
                      w.map.waterLevel));
        foreach (pos; w.store.getAll!Usable()
                       .filter!(id => w.store.get!Usable(id).effect ==
                                      UseEffect.portal)
                       .map!(id => w.store.get!Pos(id))
                       .filter!(posp => posp !is null)
                       .map!(posp => *posp))
        {
            assert(pos[0] < w.map.waterLevel,
                   format("Portal %s below water level %d", pos,
                          w.map.waterLevel));
        }
    }
}

/**
 * Generate tutorial level.
 *
 * For now, this returns a hard-coded level.  Later on we can extend this to
 * have more randomized elements.
 */
World genTutorialLevel(out int[4] startPos)
{
    auto w = new World;

    // Auto-generated by bspbuild. You probably don't want to edit this by
    // hand. :-D
    auto tree = new MapNode;
    tree.axis = 0;
    tree.pivot = 1;
    tree.left = new MapNode;
    tree.left.axis = 1;
    tree.left.pivot = 1;
    tree.left.left = new MapNode;
    tree.left.left.axis = 2;
    tree.left.left.pivot = 1;
    tree.left.left.left = new RoomNode;
    tree.left.left.left.isRoom.interior = region(vec(0,0,0,0), vec(1,1,1,5));
    tree.left.left.right = new MapNode;
    tree.left.left.right.axis = 3;
    tree.left.left.right.pivot = 4;
    tree.left.left.right.left = new RoomNode;
    tree.left.left.right.left.isRoom.interior = region(vec(0,0,3,0), vec(1,1,4,1));
    tree.left.left.right.right = new RoomNode;
    tree.left.left.right.right.isRoom.interior = region(vec(0,0,1,4), vec(1,1,5,5));
    tree.left.right = new MapNode;
    tree.left.right.axis = 2;
    tree.left.right.pivot = 2;
    tree.left.right.left = new MapNode;
    tree.left.right.left.axis = 1;
    tree.left.right.left.pivot = 4;
    tree.left.right.left.left = new RoomNode;
    tree.left.right.left.left.isRoom.interior = region(vec(0,3,0,0), vec(1,4,1,5));
    tree.left.right.left.right = new RoomNode;
    tree.left.right.left.right.isRoom.interior = region(vec(0,4,0,0), vec(1,5,2,1));
    tree.left.right.right = new MapNode;
    tree.left.right.right.axis = 3;
    tree.left.right.right.pivot = 2;
    tree.left.right.right.left = new MapNode;
    tree.left.right.right.left.axis = 1;
    tree.left.right.right.left.pivot = 4;
    tree.left.right.right.left.left = new RoomNode;
    tree.left.right.right.left.left.isRoom.interior = region(vec(0,1,3,0), vec(1,4,4,1));
    tree.left.right.right.left.right = new RoomNode;
    tree.left.right.right.left.right.isRoom.interior = region(vec(0,4,2,0), vec(1,5,4,1));
    tree.left.right.right.right = new MapNode;
    tree.left.right.right.right.axis = 2;
    tree.left.right.right.right.pivot = 4;
    tree.left.right.right.right.left = new RoomNode;
    tree.left.right.right.right.left.isRoom.interior = region(vec(0,4,2,2), vec(1,5,4,3));
    tree.left.right.right.right.right = new RoomNode;
    tree.left.right.right.right.right.isRoom.interior = region(vec(0,1,4,4), vec(1,5,5,5));
    tree.right = new MapNode;
    tree.right.axis = 2;
    tree.right.pivot = 1;
    tree.right.left = new MapNode;
    tree.right.left.axis = 0;
    tree.right.left.pivot = 2;
    tree.right.left.left = new MapNode;
    tree.right.left.left.axis = 1;
    tree.right.left.left.pivot = 4;
    tree.right.left.left.left = new RoomNode;
    tree.right.left.left.left.isRoom.interior = region(vec(1,3,0,0), vec(2,4,1,5));
    tree.right.left.left.right = new RoomNode;
    tree.right.left.left.right.isRoom.interior = region(vec(1,4,0,4), vec(2,5,1,5));
    tree.right.left.right = new MapNode;
    tree.right.left.right.axis = 3;
    tree.right.left.right.pivot = 1;
    tree.right.left.right.left = new RoomNode;
    tree.right.left.right.left.isRoom.interior = region(vec(2,4,0,0), vec(4,5,1,1));
    tree.right.left.right.right = new RoomNode;
    tree.right.left.right.right.isRoom.interior = region(vec(2,4,0,1), vec(3,5,1,5));
    tree.right.right = new MapNode;
    tree.right.right.axis = 1;
    tree.right.right.pivot = 4;
    tree.right.right.left = new RoomNode;
    tree.right.right.left.isRoom.interior = region(vec(3,0,1,1), vec(5,3,4,4));
    tree.right.right.right = new MapNode;
    tree.right.right.right.axis = 2;
    tree.right.right.right.pivot = 4;
    tree.right.right.right.left = new MapNode;
    tree.right.right.right.left.axis = 3;
    tree.right.right.right.left.pivot = 2;
    tree.right.right.right.left.left = new RoomNode;
    tree.right.right.right.left.left.isRoom.interior = region(vec(2,4,1,0), vec(4,5,4,1));
    tree.right.right.right.left.right = new RoomNode;
    tree.right.right.right.left.right.isRoom.interior = region(vec(1,4,2,2), vec(5,5,3,3));
    tree.right.right.right.right = new MapNode;
    tree.right.right.right.right.axis = 3;
    tree.right.right.right.right.pivot = 4;
    tree.right.right.right.right.left = new RoomNode;
    tree.right.right.right.right.left.isRoom.interior = region(vec(3,4,4,0), vec(5,5,5,4));
    tree.right.right.right.right.right = new RoomNode;
    tree.right.right.right.right.right.isRoom.interior = region(vec(1,4,4,4), vec(5,5,5,5));

    startPos = [0,0,0,0];

    w.map.tree = tree;
    w.map.bounds = region(vec(0,0,0,0), vec(6,6,6,6));
    w.map.waterLevel = int.max;

    // FIXME: this should be autogen'd
    void addDoor(Vec4 pos)
    {
        foreachFiltRoom(tree, w.map.bounds, (Region4 r) => r.contains(pos),
            (MapNode n, Region4 r) {
                auto node = n.isRoom;
                if (node is null) return 0;
                node.doors ~= Door(3, pos[]);
                return 0;
            }
        );
    }
    addDoor(vec(0,4,3,1));
    addDoor(vec(4,3,2,2));

    // FIXME: this should be autogen'd too.
    foreach (i; 1 .. 5)
    {
        createLadder(&w.store, Pos(i, 4, 4, 4));
    }

    auto doorTrigId = w.triggerId++;
    w.store.createObj(Pos(0,4,3,1), Tiled(TileId.lockedDoor, -2),
                      Name("locked door"), BlocksMovement(),
                      Triggerable(doorTrigId, TriggerEffect.toggleDoor));
    w.store.createObj(Pos(0,0,3,0), Name("lever"), Tiled(TileId.lever1),
                      Usable(UseEffect.trigger, "pull", doorTrigId));

    // Put some gold for the player to collect.
    enum goldPos = [
        Pos(4,0,1,1),
        Pos(4,0,1,3),
        Pos(4,0,3,1),
        Pos(4,0,3,3),
        Pos(4,2,1,1),
        Pos(4,2,1,3),
        Pos(4,2,3,1),
        Pos(4,2,3,3),
    ];
    foreach (pos; goldPos)
    {
        createGold(&w.store, pos);
    }

    // Some in-game instructions to guide the player along.
    w.store.createObj(Pos(0,0,0,0), Message([
        "This is the tutorial training area.",
        "Use the 'j' and 'k' keys to move left/right.",
    ]));
    w.store.createObj(Pos(0,0,0,4), Message([
        "Good!",
        "Now use the 'n' and 'o' keys to move forwards/backwards.",
    ]));
    w.store.createObj(Pos(0,0,4,4), Message([
        "Very good!",
        "Next, use the 'h' and 'l' keys to move ana/kata.",
    ]));
    w.store.createObj(Pos(0,4,4,4), Message([
        "Excellent!",
        "Use the 'i' and 'm' keys to climb up/down.",
    ]));
    w.store.createObj(Pos(4,4,4,4), Message([
        "Now walk to the end of the corridor.",
    ]));
    w.store.createObj(Pos(4,4,4,0), Message([
        "There's a ledge here that you can climb.",
        "To climb up, move in its direction with 'o'.",
    ]));
    w.store.createObj(Pos(3,4,0,0), Message([
        "There's another ledge on the right.",
        "To climb up, move in its direction with 'k'.",
    ]));
    w.store.createObj(Pos(2,4,0,4), Message([
        "There's a ledge ana of here.",
        "To climb up, move in its direction with 'h'.",
    ]));
    w.store.createObj(Pos(1,3,0,4), Message([
        "Good job!",
        "Ana/kata ledges are easy to miss.",
        "Always be sure to check for them.",
    ]));
    w.store.createObj(Pos(1,3,0,0), Message([
        "Do you see the next ledge?",
        "It's kata of here.",
        "Use 'l' to climb on it.",
    ]));
    w.store.createObj(Pos(0,4,3,0), Message([
        "There's a locked door on the right.",
        "To open it, you need to find the switch.",
        "Try looking in the corridor ana of here.",
        "Use the 'h' key.",
    ]), Triggerable(doorTrigId, TriggerEffect.removeMsg));

    w.store.createObj(Pos(0,0,3,0), Message([
        "You found the switch!",
        "Activate it with the Enter key.",
    ]));
    w.store.createObj(Pos(0,4,3,2), Message([
        "The blank space ahead is a hole.",
        "Walking onto it will cause you to fall down.",
        "Don't worry, you won't get hurt.",
        "Go ahead and try it with 'o'."
    ]));

    auto fallMsgTrig = w.triggerId++;
    w.store.createObj(Pos(4,4,2,2), Message([
        "See? That didn't hurt, did it?",
    ]), Triggerable(fallMsgTrig, TriggerEffect.removeMsg));
    w.store.createObj(Pos(4,3,2,2),
                      Trigger(Trigger.Type.onEnter, fallMsgTrig));

    w.store.createObj(Pos(4,3,2,2), Message([
        "To finish up, collect all the gold in the room.",
        "You can collect them just by walking on them.",
        "After collecting them all, go to the exit portal.",
        "Press '?' any time for help with movement keys.",
    ]));

    // An exit portal to end the tutorial.
    w.store.createObj(Pos(4,1,2,2), Tiled(TileId.portal), Name("exit portal"),
                      Usable(UseEffect.portal, "activate"),
                      Message([
                        "This is the exit portal.",
                        "Press Enter to activate it."
                      ]));

    return w;
}

version(none) // level gen stress test
unittest
{
    import std.stdio;
    MapGenArgs args;
    auto bounds = region(vec(0,0,0,0), vec(64,64,64,64));
    args.nBackEdges = ValRange(20, 50);
    args.nPitTraps = ValRange(50, 80);
    args.goldPct = 0.2;
    args.waterLevel = ValRange(16, 64);
    args.nMonstersA = ValRange(20, 30);

    foreach (i; 0 .. 50)
    {
        int[4] startPos;
        World w;
        for (;;)
        {
            try {
                w = genBspLevel(bounds, args, startPos);
                assert(doorsSanityCheck(w));
                break;
            } catch (Exception e) {
                writefln("[%d] oops: %s", i, e.msg);
            }
        }
        if (w is null)
            writefln("[%d] WAT?!", i);
        else
            writefln("[%d] %d gold", i, w.store.getAll!QuestItem().count);
    }
}

/**
 * Parameters for bipartite level generation.
 */
struct BipartiteGenArgs
{
    Region4 region;
    ValRange axis;
    ValRange pivot;
    ValRange waterLevel = ValRange(int.max-1, int.max);
    bool sinkDoor = true;

    int startPart;
    int portalPart;

    MapGenArgs[2] subargs;
}

/**
 * Generate a bipartite level with potentially different generation parameters
 * for each part, connected by a single door(way) that may be made a locking
 * door, etc..
 *
 * Params:
 *  args = The level generation parameters.
 */
World genBipartiteLevel(BipartiteGenArgs args,
                        out int[4] startPos,
                        out int[4] doorPos,
                        out Region4 boundsLeft,
                        out Region4 boundsRight)
{
    auto axis = args.axis.pick;
    auto pivot = args.pivot.pick;

    // Two halves of a map with distinct parameters.
    boundsLeft = args.region;
    boundsLeft.max[axis] = pivot;
    args.subargs[0].nBackEdges = ValRange(1, 5);
    args.subargs[0].goldPct = 0.1;
    args.subargs[0].nMonstersA = ValRange(1, 2);

    boundsRight = args.region;
    boundsRight.min[axis] = pivot;
    args.subargs[1].nPitTraps = ValRange(1, 5);
    args.subargs[1].nRockTraps = ValRange(3, 10);
    args.subargs[1].goldPct = 2.0;
    args.subargs[1].nMonstersA = ValRange(3, 4);

    auto w = new World;
    auto tree1 = genTree(boundsLeft, args.subargs[0].tree);
    auto tree2 = genTree(boundsRight, args.subargs[1].tree);

    // Stitch two halves of map together
    w.map.waterLevel = args.waterLevel.pick;
    w.map.tree = new MapNode;
    w.map.tree.axis = axis;
    w.map.tree.pivot = pivot;
    w.map.tree.left = tree1;
    w.map.tree.right = tree2;
    w.map.bounds = args.region;

    // Place doorway between two halves.
    RoomNode[2] candidate;
    int n;
    foreachCandidateDoor(w.map.tree, args.region,
                         (MapNode l, MapNode r, int[4] pos)
    {
        auto left = l.isRoom;
        auto right = r.isRoom;
        if (left && right && uniform(0, ++n) == 0)
        {
            candidate[0] = left;
            candidate[1] = right;
            doorPos = pos;
        }
        return 0;
    });
    if (n == 0)
        throw new GenCorridorsException("No viable door placement found");

    auto d = Door(axis);
    assert(doorPos[axis] == pivot-1);
    d.pos = doorPos;
    candidate[0].doors ~= d;
    candidate[1].doors ~= d;

    // Finish up level geometry
    // IMPORTANT: connecting door must be placed before this, otherwise
    // resizeRoom() may make the door inaccessible.
    genGeometry(w, tree1, boundsLeft, args.subargs[0]);
    genGeometry(w, tree2, boundsRight, args.subargs[1]);

    if (args.sinkDoor)
    {
        // Need to do this manually because genGeometry can't do cross-region
        // sinking.
        auto floorCoor = min(candidate[0].interior.max[0],
                             candidate[1].interior.max[0]);
        foreach (node; candidate[])
        {
            auto i = node.doors.countUntil(d);
            assert(i >= 0);
            node.doors[i].pos[0] = floorCoor - 1;
        }
        doorPos[0] = floorCoor - 1;
    }

    // Generate startPos in selected half of level.
    auto filt = RandomPosFilt(Dryness.dry, Occupancy.empty, Support.below,
                              Distrib.floor);
    Tuple!(MapNode, Vec4) roomPos;
    switch (args.startPart)
    {
        case 0:
            roomPos = randomRoomPos(w, tree1, filt);
            break;

        case 1:
            roomPos = randomRoomPos(w, tree2, filt);
            break;

        default:
            assert(0, "Invalid start index for bipartite level gen");
    }
    auto startRoom = roomPos[0];
    startPos = roomPos[1];

    // Place objects and deco
    genObjects(w, tree1, boundsLeft, args.subargs[0], startRoom);
    genObjects(w, tree2, boundsRight, args.subargs[1], startRoom);

    switch (args.portalPart)
    {
        case 0:
            genPortal(w, tree1, boundsLeft);
            break;

        case 1:
            genPortal(w, tree2, boundsRight);
            break;

        default:
            assert(0, "Invalid portal index for bipartite level gen");
    }

    return w;
}

/**
 * Generate a door + lever combo.
 */
void genDoorAndLever(World w, int[4] doorPos, MapNode leverTree,
                     Region4 leverBounds)
{
    // Actual locked door object
    auto doorTrigId = w.triggerId++;
    w.store.createObj(Pos(doorPos), Tiled(TileId.lockedDoor, -2),
                      Name("locked door"), BlocksMovement(),
                      Triggerable(doorTrigId, TriggerEffect.toggleDoor));

    // Lever for opening the door
    Pos leverPos, floorPos;
    do
    {
        leverPos = Pos(randomPos(w, leverTree,
                                 RandomPosFilt(Dryness.any, Occupancy.empty,
                                               Support.below, Distrib.floor)));
        floorPos = leverPos + vec(1,0,0,0);
    } while (!w.store.getAllBy!Pos(leverPos).empty ||
             !w.locationHas!BlocksMovement(floorPos));
    w.store.createObj(leverPos, Name("big lever"), Tiled(TileId.lever1),
                      Usable(UseEffect.trigger, "pull", doorTrigId),
                      Weight(10));
}

/**
 * Scratch pad function for generating various test levels.
 */
World genTestLevel()(out int[4] startPos)
{
    auto root = new MapNode;
    root.axis = 1;
    root.pivot = 5;

    root.left = new RoomNode;
    root.left.isRoom.interior = region(vec(1,1,1,1), vec(3,4,4,4));
    root.left.isRoom.doors = [
        Door(1, [1,4,2,2]),
    ];

    root.right = new RoomNode;
    root.right.isRoom.interior = region(vec(1,5,1,1), vec(8,8,4,4));
    root.right.isRoom.doors = [
        Door(1, [1,4,2,2]),
    ];

    auto w = new World;
    w.map.tree = root;
    w.map.bounds = region(vec(1,1,1,1), vec(9,9,5,5));
    w.map.waterLevel = int.max;

    if (!tryAddSpiralStairs(w, root.right.isRoom, root.right.isRoom.doors[0]))
        assert(0, "Failed to add spiral stairs");

    //addLadders(w, w.map.tree, w.map.bounds);

    startPos = [7,6,2,2];
    return w;
}

// vim:set ai sw=4 ts=4 et:
