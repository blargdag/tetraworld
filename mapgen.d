/**
 * Map generation module.
 * ----------------------------------------------------------------------------
 * Map representation notes:
 *
 * Maps are represented using BSP trees (see bsp.d). The default map generators
 * use genBsp() to create a random BSP tree, subject to some constraints, but
 * it can be generated by any means you wish (see genTutorialLevel() for
 * example).  Rooms are assumed to occupy one leaf node (MapNode) each.
 *
 * Doors must be duplicated in *both* rooms that they connect. This doesn't
 * matter during map redition (leftmost doors do not get rendered), but it
 * *does* matter during map generation because, e.g., leftmost doors are
 * required to generate ladder objects, otherwise there would be no ladders
 * connecting to leftmost doors.
 *
 * The actual size of the room may differ from the BSP node's bounding region;
 * the .interior of the room represents the actual interior of the room (NOT
 * including any outer walls).
 *
 * Copyright: (C) 2012-2021  blargdag@quickfur.ath.cx
 *
 * This file is part of Tetraworld.
 *
 * Tetraworld is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free
 * Software Foundation, either version 2 of the License, or (at your option)
 * any later version.
 *
 * Tetraworld is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * Tetraworld.  If not, see <http://www.gnu.org/licenses/>.
 */
module mapgen;

import std.algorithm;
import std.math : abs;
import std.random : uniform;
import std.range;

import bsp;
import components;
import gamemap;
import objects;
import rndutil;
import terrain;
import vector;
import world;

/**
 * Initialize room interiors to the maximum size per BSP node, minus a 1-tile
 * space for the inter-room walls.
 */
void setRoomInteriors(MapNode root, Region!(int,4) bounds)
{
    foreachRoom(root, bounds, (Region!(int,4) r, MapNode node) {
        node.interior = region(r.min, r.max - vec(1,1,1,1));
        return 0;
    });
}

unittest
{
    // Test case 1:
    //   0123456789
    // 0 ##########
    // 1 #   #    #
    // 2 #   #    #
    // 3 #####    #
    // 4 #   #    #
    // 5 #   #    #
    // 6 ##########
    auto root = new MapNode;
    root.axis = 2;
    root.pivot = 5;

    root.left = new MapNode;
    root.left.axis = 3;
    root.left.pivot = 4;
    root.left.left = new MapNode;
    root.left.right = new MapNode;

    root.right = new MapNode;

    auto bounds = region(vec(0,0,1,1), vec(2,2,10,7));
    setRoomInteriors(root, bounds);

    assert(root.left.left.interior == region(vec(0,0,1,1), vec(1,1,4,3)));
    assert(root.left.right.interior == region(vec(0,0,1,4), vec(1,1,4,6)));
    assert(root.right.interior == region(vec(0,0,5,1), vec(1,1,9,6)));
}

/**
 * Returns: The total interior volumes of the rooms in the given BSP tree.
 */
int floorArea(MapNode node)
{
    if (node.isLeaf)
        return iota(1, 4)
            .map!(i => node.interior.max[i] - node.interior.min[i])
            .fold!((a, b) => a*b)(1);
    else
        return floorArea(node.left) + floorArea(node.right);
}

unittest
{
    auto tree = new MapNode;
    tree.interior = region(vec(1,1,1,1), vec(3,3,3,3));
    assert(floorArea(tree) == 8);

    tree.interior = region(vec(1,1,1,1), vec(20,3,3,3));
    assert(floorArea(tree) == 8);

    tree.interior = region(vec(1,1,1,1), vec(20,4,3,3));
    assert(floorArea(tree) == 12);
}

private class GenCorridorsException : Exception
{
    this(string msg) { super(msg); }
}

/**
 * Prerequisities: The .interior of the node must have already been set.
 *
 * Returns: The filter region corresponding to the rightmost wall of the given
 * node along the given axis. (Note that it is not the *actual* rightmost wall,
 * since that lies inside the node bounds, whereas the wall filter lies 1 tile
 * past that in order to intersect with the adjacent room's bounds.)
 */
Region!(int,4) rightWallFilt(MapNode node, Region!(int,4) bounds, int axis)
{
    auto filt = node.interior;
    filt.min[axis] = filt.max[axis] = bounds.max[axis];
    return filt;
}

unittest
{
    auto node = new MapNode;
    auto bounds = region(vec(1,1,1,1), vec(5,5,5,5));
    setRoomInteriors(node, bounds);
    assert(rightWallFilt(node, bounds, 0) ==
           region(vec(5,1,1,1), vec(5,4,4,4)));
}

/**
 * Prerequisities: The .interior of the node must have already been set.
 *
 * Returns: The filter region corresponding to the leftmost wall of the given
 * node along the given axis. (Note that it is not the *actual* leftmost wall,
 * since that lies outside the node bounds, whereas the wall filter lies along
 * the first row of tiles in the room's interior in order to intersect with the
 * adjacent room's filter.)
 */
Region!(int,4) leftWallFilt(MapNode node, Region!(int,4) bounds, int axis)
{
    auto filt = node.interior;
    filt.min[axis] = filt.max[axis] = bounds.min[axis];
    return filt;
}

unittest
{
    auto node = new MapNode;
    auto bounds = region(vec(1,1,1,1), vec(5,5,5,5));
    setRoomInteriors(node, bounds);
    assert(leftWallFilt(node, bounds, 0) ==
           region(vec(1,1,1,1), vec(1,4,4,4)));
}

/**
 * Generate a random position corresponding to a door in the given intersection
 * of two wall filters.
 *
 * Returns: true if successful, false if a suitable position could not be
 * found.
 */
bool randomEdgePos(Region!(int,4) ir, int axis, out int[4] basePos)
    in (ir.min[axis] == ir.max[axis])
{
    foreach (i; 0 .. 4)
    {
        import std.random : uniform;
        if (i == axis)
        {
            assert(ir.min[i] == ir.max[i]);
            basePos[i] = ir.min[i] - 1;
        }
        else if (ir.max[i] - ir.min[i] > 0)
            basePos[i] = uniform(ir.min[i], ir.max[i]);
        else
        {
            // Overlap is too small to place a door, skip.
            return false;
        }
    }
    return true;
}

/**
 * Iterate over pairs of rightmost nodes in the left subtree and leftmost nodes
 * in the right subtree that share a wall in which a door can be inserted to
 * connect the left subtree to the right subtree.
 *
 * Params:
 *  root = The root of the BSP tree.
 *  region = The bounding region.
 *  dg = The delegate to invoke on each door candidate. It should return
 *      0 to continue iteration, or non-zero to terminate iteration.
 */
void foreachCandidateDoor(R)(MapNode root, R region,
                             int delegate(MapNode left, MapNode right,
                                          int[4] basePos) dg)
{
    root.left.foreachFiltRoom(leftRegion(region, root.axis, root.pivot),
        (R r) => r.max[root.axis] >= root.pivot, (MapNode node1, R r1)
    {
        R wallFilt = rightWallFilt(node1, r1, root.axis);

        return root.right.foreachFiltRoom(
            rightRegion(region, root.axis, root.pivot), wallFilt,
            (MapNode node2, R r2)
        {
            auto wallFilt2 = leftWallFilt(node2, r2, root.axis);

            auto ir = wallFilt.intersect(wallFilt2);
            int[4] basePos;
            if (!randomEdgePos(ir, root.axis, basePos))
                return 0; // No overlap or too narrow, skip

            return dg(node1, node2, basePos);
        });
    });
}

unittest
{
    // Test case 1:
    //   0123456
    // 0 #######
    // 1 #  #  #
    // 2 #######
    auto root = new MapNode;
    root.axis = 2;
    root.pivot = 4;
    root.left = new MapNode;
    root.right = new MapNode;

    auto bounds = region(vec(0,0,1,1), vec(2,2,7,3));
    setRoomInteriors(root, bounds);

    MapNode[2][] pairs;
    int[] ys;

    foreachCandidateDoor(root, bounds, (MapNode left, MapNode right,
                                        int[4] basePos)
    {
        pairs ~= [ left, right ];
        assert(basePos[0] == 0);
        assert(basePos[1] == 0);
        assert(basePos[2] == 3);
        ys ~= basePos[3];
        return 0;
    });

    auto expected = [
        [ root.left, root.right ],
    ];
    assert(pairs == expected);

    assert(ys[0] == 1);
}

unittest
{
    // Test case 2:
    //   0123456789
    // 0 ##########
    // 1 #  #  #  #
    // 2 #  #  #  #
    // 3 #######  #
    // 4 #     #  #
    // 5 #     ####
    // 6 #     #  #
    // 7 #     #  #
    // 8 ##########
    auto root = new MapNode;
    root.axis = 2;
    root.pivot = 7;

    root.left = new MapNode;
    root.left.axis = 3;
    root.left.pivot = 4;

    root.left.left = new MapNode;
    root.left.left.axis = 2;
    root.left.left.pivot = 4;
    root.left.left.left = new MapNode;
    root.left.left.right = new MapNode;

    root.left.right = new MapNode;

    root.right = new MapNode;
    root.right.axis = 3;
    root.right.pivot = 6;
    root.right.left = new MapNode;
    root.right.right = new MapNode;

    auto bounds = region(vec(0,0,1,1), vec(2,2,10,9));
    setRoomInteriors(root, bounds);

    MapNode[][] pairs;
    int[] ys;

    foreachCandidateDoor(root, bounds, (MapNode left, MapNode right,
                                        int[4] basePos)
    {
        pairs ~= [ left, right ];
        assert(basePos[0] == 0);
        assert(basePos[1] == 0);
        assert(basePos[2] == 6);
        ys ~= basePos[3];
        return 0;
    });

    MapNode[][] expected = [
        [ root.left.left.right, root.right.left ],
        [ root.left.right, root.right.left ],
        [ root.left.right, root.right.right ],
    ];
    assert(pairs.equal!equal(expected));

    assert(1 <= ys[0] && ys[0] < 3);
    assert(ys[1] == 4);
    assert(6 <= ys[2] && ys[2] < 8);
}

/**
 * Generate corridors based on BSP tree structure.
 *
 * Prerequisites: The .interior bounds of each leaf node must have already been
 * set, either by setRoomInteriors(), or some other means.
 *
 * Throws: GenCorridorsException if the given BSP tree does not allow doors to
 * be placed according to the BSP connectivity structure. This is pretty rare
 * but *does* happen (2-8% for a 64^4 map, seems rarer on smaller maps), so the
 * caller should catch this exception and rebuild with a different BSP tree
 * instead.
 */
void genCorridors(R)(MapNode root, R region)
    if (is(R == Region!(int,n), size_t n))
{
    if (root.isLeaf) return;

    genCorridors(root.left, leftRegion(region, root.axis, root.pivot));
    genCorridors(root.right, rightRegion(region, root.axis, root.pivot));

    MapNode[2] candidate;
    int[4] basePos;
    int n;

    foreachCandidateDoor(root, region, (MapNode left, MapNode right,
                                        int[4] pos)
    {
        if (uniform(0, ++n) == 0)
        {
            candidate[0] = left;
            candidate[1] = right;
            basePos = pos;
        }
        return 0;
    });

    if (n == 0)
        throw new GenCorridorsException("No viable door placement found");

    auto d = Door(root.axis);
    d.pos = basePos;
    candidate[0].doors ~= d;
    candidate[1].doors ~= d;
}

unittest
{
    // Test case 1:
    //   0123456789
    // 0 ##########
    // 1 #   ######
    // 2 #   -    #
    // 3 #####    #
    // 4 #####    #
    // 5 ##########
    auto root = new MapNode;
    root.axis = 2;
    root.pivot = 5;

    root.left = new MapNode;
    root.left.interior = region(vec(0,0,1,1), vec(1,1,4,3));

    root.right = new MapNode;
    root.right.interior = region(vec(0,0,5,2), vec(1,1,9,5));

    auto bounds = region(vec(0,0,1,1), vec(1,1,10,6));
    genCorridors(root, bounds);

    assert(root.doors == []);
    assert(root.left.doors == [ Door(2, [0,0,4,2]) ]);
    assert(root.right.doors == [ Door(2, [0,0,4,2]) ]);
}

unittest
{
    // Test case 2:
    //   0123456789
    // 0 ##########
    // 1 #   ######
    // 2 #   -    #
    // 3 #   #    #
    // 4 #####    #
    // 5 ##########
    auto root = new MapNode;
    root.axis = 2;
    root.pivot = 5;

    root.left = new MapNode;
    root.left.interior = region(vec(0,0,1,1), vec(1,1,4,4));

    root.right = new MapNode;
    root.right.interior = region(vec(0,0,5,2), vec(1,1,9,5));

    auto bounds = region(vec(0,0,1,1), vec(1,1,10,6));
    genCorridors(root, bounds);

    assert(root.doors == []);
    assert((root.left.doors == [ Door(2, [0,0,4,2]) ] &&
            root.right.doors == [ Door(2, [0,0,4,2]) ]) ||
           (root.left.doors == [ Door(2, [0,0,4,3]) ] &&
            root.right.doors == [ Door(2, [0,0,4,3]) ]));
}

/**
 * Returns: true if the given door is valid for the given room interior, false
 * otherwise.
 */
bool isValidDoor()(Region!(int,4) interior, Door d)
{
    return iota(4)
        .map!(i => (i == d.axis) ? (d.pos[i] == interior.min[i] - 1 ||
                                    d.pos[i] == interior.max[i])
                                 : (interior.min[i] <= d.pos[i] &&
                                    d.pos[i] < interior.max[i]))
        .fold!((a,b) => a && b)(true);
}

unittest
{
    // Test case:
    //   01234
    // 0 #####
    // 1 #   #
    // 2 #   #
    // 3 #   #
    // 4 #####
    auto interior = region(vec(1,1,1,1), vec(4,4,4,4));

    assert( isValidDoor(interior, Door(0, [0,1,1,1])));
    assert(!isValidDoor(interior, Door(0, [1,1,1,1])));
    assert(!isValidDoor(interior, Door(0, [2,1,1,1])));
    assert(!isValidDoor(interior, Door(0, [3,1,1,1])));
    assert( isValidDoor(interior, Door(0, [4,1,1,1])));
    assert(!isValidDoor(interior, Door(0, [5,1,1,1])));

    assert( isValidDoor(interior, Door(1, [1,0,1,1])));
    assert(!isValidDoor(interior, Door(1, [1,1,1,1])));
    assert(!isValidDoor(interior, Door(1, [1,2,1,1])));
    assert(!isValidDoor(interior, Door(1, [1,3,1,1])));
    assert( isValidDoor(interior, Door(1, [1,4,1,1])));
    assert(!isValidDoor(interior, Door(1, [1,5,1,1])));

    assert(!isValidDoor(interior, Door(2, [2,2,0,0])));
    assert( isValidDoor(interior, Door(2, [2,2,0,1])));
    assert( isValidDoor(interior, Door(2, [2,2,0,2])));
    assert( isValidDoor(interior, Door(2, [2,2,0,3])));
    assert(!isValidDoor(interior, Door(2, [2,2,0,4])));
    assert(!isValidDoor(interior, Door(2, [2,2,0,5])));
}

/**
 * Sanity checker for door placements.
 */
bool doorsSanityCheck()(World w)
{
    bool result = true;
    foreachRoom(w.map.tree, w.map.bounds, (Region!(int,4) bounds, MapNode node)
    {
        foreach (d; node.doors)
        {
            import std.stdio : writefln;
            if (!isValidDoor(node.interior, d))
            {
                writefln("Interior check failed: interior=%s d=%s",
                         node.interior, d);
                goto FAIL;
            }

            auto v = vec(0,0,0,0);
            v[d.axis] = 1;
            if (w.store.get!BlocksMovement(w.map[vec(d.pos) + v]) !is null ||
                w.store.get!BlocksMovement(w.map[vec(d.pos) - v]))
            {
                writefln("Walkability test failed: interior=%s d=%s %s",
                    node.interior, d,
                    [ vec(d.pos)+v, vec(d.pos), vec(d.pos)-v ]
                        .map!(pos => w.getAllAt(Pos(pos))
                                      .map!(id => w.store.get!Name(id).name))
                );
                goto FAIL;
            }
        }
        return 0;

    FAIL:
        result = false;
        return 1;
    });
    return result;
}

unittest
{
    // Test case:
    //   0123456
    // 0 #######
    // 1 #  -  #
    // 2 #  #  #
    // 3 #######
    auto bounds = region(vec(0,0,0,0), vec(4,7,2,2));
    auto root = new MapNode;
    root.axis = 1;
    root.pivot = 4;

    root.left = new MapNode;
    root.left.interior = region(vec(1,1,0,0), vec(3,3,1,1));
    root.left.doors = [ Door(1, [1,3,0,0]) ];

    root.right = new MapNode;
    root.right.interior = region(vec(1,4,0,0), vec(3,6,1,1));
    root.right.doors = [ Door(1, [1,3,0,0]) ];

    auto w = new World;
    w.map.tree = root;
    w.map.bounds = bounds;

    assert(doorsSanityCheck(w));

    // Blocking objects are NOT included in the doors check, because e.g.,
    // creatures could be generated next to doors, but that does not make the
    // door placement wrong.
    w.store.createObj(Name("blocker"), BlocksMovement());
    assert(doorsSanityCheck(w));
}

/**
 * Given the boundary between two nodes and a list of doors, returns true if
 * there is at least one door in the list that lies on that boundary.
 *
 * Params:
 *  boundary = The boundary to check. The boundary should lie exactly between
 *      two BSP nodes, i.e., boundary.min[axis] == boundary.max[axis] ==
 *      rightNodeBounds.min[axis].
 *  axis = The axis of the connection (assumed to be the perpendicular of the
 *      boundary).
 *  doors = The list of doors to check.
 */
bool hasDoorAtBoundary(Region!(int,4) boundary, int axis, Door[] doors)
    in (boundary.min[axis] == boundary.max[axis])
{
    auto wall = boundary;
    wall.min[axis]--;

    foreach (d; doors)
    {
        if (wall.contains(vec(d.pos)))
            return true;
    }
    return false;
}

unittest
{
    auto r = region(vec(0,0,5,0), vec(5,5,5,5));
    assert( hasDoorAtBoundary(r, 2, [ Door(2, [1,1,4,1]) ]));
    assert( hasDoorAtBoundary(r, 2, [ Door(2, [0,0,4,0]) ]));
    assert( hasDoorAtBoundary(r, 2, [ Door(2, [4,4,4,4]) ]));

    assert(!hasDoorAtBoundary(r, 2, [ Door(0, [1,1,1,1]) ]));
    assert(!hasDoorAtBoundary(r, 2, [ Door(2, [1,1,1,1]) ]));
    assert(!hasDoorAtBoundary(r, 2, [ Door(2, [4,4,3,4]) ]));
    assert(!hasDoorAtBoundary(r, 2, [ Door(2, [4,4,5,4]) ]));

    assert( hasDoorAtBoundary(r, 2, [ Door(2, [6,2,4,2]),
                                      Door(2, [4,4,4,4]) ]));
}

/**
 * Insert additional doors to randomly-picked rooms outside of the BSP
 * connectivity structure, so that non-trivial topology is generated.
 *
 * Prerequisites: The .interior's of every room must have already been set,
 * usually via setRoomInteriors().
 *
 * Params:
 *  root = Root of BSP tree.
 *  region = Initial bounding region.
 *  count = Number of additional doors to insert.
 *  maxRetries = Maximum number of failures while looking for a room pair that
 *      can accomodate an extra door. This is to prevent infinite loops in case
 *      the given tree cannot accomodate another `count` doors.
 *  doorFilter = An optional delegate that accepts or rejects a door, and
 *      optionally marks it up in some way, e.g., with an .extra flag set, or
 *      some randomized door type. The delegate is passed the room nodes that
 *      it will connect. Returns: true if the door should be added, false
 *      otherwise. Note that returning false will count towards the number of
 *      failed attempts.
 *  pickAxis = An optional delegate that selects which axis to use for finding
 *      potential back-edges.
 *  allowMultiple = Whether or not to allow multiple doors on the same wall.
 *      Default: false.
 */
void genBackEdges(R)(MapNode root, R region, int count, int maxRetries = 15)
{
    import std.random : uniform;
    genBackEdges(root, region, count, maxRetries,
                 (in MapNode[2], ref Door) => true,
                 (MapNode node, R bounds) => uniform(0, 4),
                 false);
}

/// ditto
void genBackEdges(R)(MapNode root, R region, int count, int maxRetries,
                     bool delegate(in MapNode[2] node, ref Door) doorFilter,
                     int delegate(MapNode, R) pickAxis,
                     bool allowMultiple)
{
    import std.random : uniform;
    import rndutil : pickOne;
    while (count > 0 && maxRetries > 0)
    {
        static struct RightRoom
        {
            MapNode node;
            R region;
            int[4] basePos;
        }

        auto success = root.randomRoom!(RandomRoomDist.volume)(region,
            (MapNode node, R bounds)
        {
            // Randomly select a wall of the room.
            auto axis = pickAxis(node, bounds);
            if (axis == invalidAxis)
                return false;
            R wallFilt = rightWallFilt(node, bounds, axis);

//import std;writefln("left=%s (wallFilt=%s)", node.interior, wallFilt);
            // Find an adjacent room that can be joined to this one via a door.
            RightRoom[] targets;
            root.foreachFiltRoom(region, wallFilt, (MapNode node2, R r2) {
                import std.algorithm : canFind, filter, fold;
                import std.range : iota;

                auto wallFilt2 = leftWallFilt(node2, r2, axis);
                auto ir = wallFilt.intersect(wallFilt2);

//import std;writefln("left=%s (wallFilt=%s) right=%s (wallFilt2=%s) ir=%s", node.interior, wallFilt, node2.interior, wallFilt2, ir);
                // Check that there isn't already a door between these two
                // rooms.
                if (!allowMultiple && hasDoorAtBoundary(ir, axis, node.doors))
                    return 0;

                int[4] basePos;
                if (!randomEdgePos(ir, axis, basePos))
                {
                    // Overlap is too small to place a door, skip.
                    return 0;
                }

                // Avoid coincident doors
                if (node.doors.canFind!(d => d.pos == basePos))
                    return 0;

//import std;writefln("basePos=%s", basePos);
                targets ~= RightRoom(node2, r2, basePos);
                return 0;
            });

            if (targets.empty)
                return false; // couldn't match anything for this room

            auto rightRoom = targets.pickOne;

            auto d = Door(axis);
            d.pos = rightRoom.basePos;
            if (!doorFilter([node, rightRoom.node], d))
                return false;

            import std.format : format;
            assert(isValidDoor(node.interior, d) &&
                   isValidDoor(rightRoom.node.interior, d),
                   format("left.interior=%s right.interior=%s d=%s",
                          node.interior, rightRoom.node.interior, d));

//import std;writefln("door=%s", d);
            node.doors ~= d;
            rightRoom.node.doors ~= d;

            return true;
        });

        if (success)
            count--;
        else
            maxRetries--;
    }
}

unittest
{
    // Test case:
    //   012345678
    // 0 #########
    // 1 ##      #
    // 2 ##      #
    // 3 ##X###|##
    // 4 #  -    #
    // 5 #  #    #
    // 6 #########
    auto bounds = region(vec(1,1,0,0), vec(9,7,2,2));

    auto root = new MapNode;
    root.axis = 1;
    root.pivot = 4;

    root.left = new MapNode;
    root.left.interior = region(vec(2,1,0,0), vec(8,3,1,1));
    root.left.doors = [ Door(1, [6,3,0,0]) ];

    root.right = new MapNode;
    root.right.axis = 0;
    root.right.pivot = 4;

    root.right.left = new MapNode;
    root.right.left.interior = region(vec(1,4,0,0), vec(3,6,1,1));
    root.right.left.doors = [ Door(0, [3,4,0,0]) ];

    root.right.right = new MapNode;
    root.right.right.interior = region(vec(4,4,0,0), vec(8,6,1,1));
    root.right.right.doors = [ Door(1, [6,3,0,0]),
                               Door(0, [3,4,0,0]) ];

    genBackEdges(root, bounds, 1, 99, (in MapNode[2], ref Door) => true,
                 (MapNode, Region!(int,4)) => 1, false);
    assert(root.right.left.doors.canFind(Door(1, [2,3,0,0])));
}

/**
 * Returns: The minimum region of the given room node that covers all Doors.
 */
Region!(int,4) minCore(Region!(int,4) interior, Door[] doors)
    out(r; iota(4).all!(i => interior.min[i] <= r.min[i] &&
                             r.max[i] <= interior.max[i]))
{
    auto core = region(interior.max, interior.min);
    foreach (d; doors)
    {
        foreach (i; 0 .. 4)
        {
            if (i == d.axis)
            {
                if (core.min[i] > d.pos[i] + 1)
                    core.min[i] = d.pos[i] + 1;
                if (core.max[i] < d.pos[i])
                    core.max[i] = d.pos[i];
            }
            else
            {
                if (core.min[i] > d.pos[i])
                    core.min[i] = d.pos[i];
                if (core.max[i] < d.pos[i] + 1)
                    core.max[i] = d.pos[i] + 1;
            }
        }
    }
    return core;
}

unittest
{
    // Test case 1:
    //   012345
    // 0 ######
    // 1 -....#
    // 2 #....#
    // 3 #....#
    // 4 #....#
    // 5 ##-###
    auto r = region(vec(0,0,1,1), vec(1,1,5,5));
    auto doors = [
        Door(2, [0,0,0,1]),
        Door(3, [0,0,2,5]),
    ];

    assert(minCore(r, doors) == region(vec(0,0,1,1), vec(1,1,3,5)));

    // Test case 2:
    //   012345
    // 0 ######
    // 1 #....#
    // 2 #....#
    // 3 -....#
    // 4 #....#
    // 5 ##-###
    doors = [
        Door(2, [0,0,0,3]),
        Door(3, [0,0,2,5]),
    ];

    assert(minCore(r, doors) == region(vec(0,0,1,3), vec(1,1,3,5)));

    // Test case 3:
    //   012345
    // 0 ######
    // 1 #....#
    // 2 #....-
    // 3 #....#
    // 4 #....#
    // 5 ##-###
    doors = [
        Door(2, [0,0,5,2]),
        Door(3, [0,0,2,5]),
    ];

    assert(minCore(r, doors) == region(vec(0,0,2,2), vec(1,1,5,5)));

    // Test case 4:
    //   012345
    // 0 ###-##
    // 1 #....#
    // 2 #....-
    // 3 #....#
    // 4 #....#
    // 5 ######
    doors = [
        Door(2, [0,0,5,2]),
        Door(3, [0,0,3,0]),
    ];

    assert(minCore(r, doors) == region(vec(0,0,3,1), vec(1,1,5,3)));

    // Test case 5:
    //   012345
    // 0 ###-##
    // 1 #....#
    // 2 #....#
    // 3 #....#
    // 4 #....#
    // 5 ##-###
    doors = [
        Door(3, [0,0,3,0]),
        Door(3, [0,0,2,5]),
    ];

    assert(minCore(r, doors) == region(vec(0,0,2,1), vec(1,1,4,5)));

    // Test case 6:
    //   012345
    // 0 ###-##
    // 1 #....#
    // 2 -....#
    // 3 #....#
    // 4 #....#
    // 5 ######
    doors = [
        Door(2, [0,0,0,2]),
        Door(3, [0,0,3,0]),
    ];

    assert(minCore(r, doors) == region(vec(0,0,1,1), vec(1,1,4,3)));
}

/**
 * Iterate over leaf nodes in the given BSP tree and assign room interiors with
 * random sizes.
 *
 * Prerequisites: Initial (maximal) room interiors must have already been set.
 * Doors must have already been computed, since minimum room interior regions
 * are computed based on the position of doors.
 */
void resizeRooms(R)(MapNode root, R region, int minRoomDim)
    if (is(R == Region!(int,n), size_t n))
{
    foreachRoom(root, region, (R bounds, MapNode node) {
        import std.random : uniform;

        // Find minimum region room must cover in order for exits to connect.
        auto core = minCore(node.interior, node.doors);

        // Expand minimum region to be at least (minRoomDim) tiles wide in each
        // direction.
        foreach (i; 0 .. 4)
        {
            if (node.interior.length(i) < minRoomDim)
                continue;   // FIXME: should be an error

            while (core.length(i) < minRoomDim)
            {
                if (uniform(0, 2) == 0)
                {
                    if (node.interior.min[i] < core.min[i])
                        core.min[i]--;
                }
                else
                {
                    if (core.max[i] < node.interior.max[i])
                        core.max[i]++;
                }
            }
        }

        // Select random size between bounding region and minimum region.
        R result;
        foreach (i; 0 .. 4)
        {
            result.min[i] = uniform!"[]"(node.interior.min[i], core.min[i]);
            result.max[i] = uniform!"[]"(core.max[i], node.interior.max[i]);
        }

        node.interior = result;
        return 0;
    });
}

unittest
{
    // Test case: (base case)
    //   012345
    // 0 ####|#
    // 1 -    #
    // 2 #    -
    // 3 #|####
    auto bounds = region(vec(0,0,0,0), vec(6,4,2,2));
    auto root = new MapNode;
    root.interior = region(vec(1,1,0,0), vec(5,3,1,1));
    root.doors = [
        Door(0, [0,1,0,0]),
        Door(1, [4,1,0,0]),
        Door(0, [5,2,0,0]),
        Door(1, [1,3,0,0]),
    ];

    resizeRooms(root, bounds, 3);

    assert(root.interior == region(vec(1,1,0,0), vec(5,3,1,1)));
}

/**
 * Generate ladders for reaching doors that are too high to reach from floor.
 *
 * Prerequisites: Room interiors must already have been set.
 */
void addLadders(World w, MapNode tree, Region!(int,4) bounds)
{
    foreachRoom(tree, bounds, (Region!(int,4) bounds, MapNode node) {
        foreach (d; node.doors)
        {
            if (d.axis == 0 && d.type == Door.Type.normal &&
                d.pos[0] < node.interior.min[0])
            {
                // Vertical exits
                foreach (i; d.pos[0] .. node.interior.max[0])
                {
                    createLadder(&w.store, Pos(i, d.pos[1], d.pos[2],
                                               d.pos[3]));
                }
            }
            else if (d.axis != 0 && d.pos[0] < node.interior.max[0] - 2)
            {
                // Horizontal exits
                auto pos = d.pos;
                pos[d.axis] = (d.pos[d.axis] == node.interior.max[d.axis]) ?
                              d.pos[d.axis] - 1 : d.pos[d.axis] + 1;
                foreach (i; d.pos[0] + 1 .. node.interior.max[0])
                {
                    createLadder(&w.store, Pos(i, pos[1], pos[2], pos[3]));
                }
            }
        }
        return 0;
    });
}

unittest
{
    import gamemap, terrain;

    // Test map:
    //    0123456
    //  0 ###=###
    //  1 #  =  #
    //  2 |_ =  #
    //  3 #= =  |
    //  4 #= =  #
    //  5 #######
    MapNode root = new MapNode;
    root.interior = Region!(int,4)(vec(1,1,1,1), vec(5,6,2,2));
    root.doors ~= Door(1, [2,0,1,1], Door.Type.normal);
    root.doors ~= Door(0, [0,3,1,1], Door.Type.normal);
    root.doors ~= Door(1, [3,6,1,1], Door.Type.normal);

    auto w = new World;
    w.map.tree = root;

    // Ladder placement should use interior, not bounding region.
    w.map.bounds = region(vec(0,0,0,0), vec(9,9,9,9));

    w.map.waterLevel = int.max;

    addLadders(w, w.map.tree, w.map.bounds);

    bool hasLadder(Pos pos)
    {
        return w.getAllAt(pos)
                .canFind!(id => w.store.get!Tiled(id).tileId == TileId.ladder);
    }

    assert(!hasLadder(Pos(0,1,1,1)));
    assert(!hasLadder(Pos(1,1,1,1)));
    assert(!hasLadder(Pos(2,1,1,1)));
    assert( hasLadder(Pos(3,1,1,1)));
    assert( hasLadder(Pos(4,1,1,1)));
    assert(!hasLadder(Pos(5,1,1,1)));

    assert( hasLadder(Pos(0,3,1,1)));
    assert( hasLadder(Pos(1,3,1,1)));
    assert( hasLadder(Pos(2,3,1,1)));
    assert( hasLadder(Pos(3,3,1,1)));
    assert( hasLadder(Pos(4,3,1,1)));
    assert(!hasLadder(Pos(5,3,1,1)));

    assert(!hasLadder(Pos(0,5,1,1)));
    assert(!hasLadder(Pos(1,5,1,1)));
    assert(!hasLadder(Pos(2,5,1,1)));
    assert(!hasLadder(Pos(3,5,1,1)));
    assert(!hasLadder(Pos(4,5,1,1)));
    assert(!hasLadder(Pos(5,5,1,1)));
}

unittest
{
    import gamemap, terrain;

    // Test map:
    //    0123456
    //  0 ###=###
    //  1 #  =  #
    //  2 #  = _|
    //  3 |  = =#
    //  4 #  = =#
    //  5 #######
    MapNode root = new MapNode;
    root.interior = Region!(int,4)(vec(1,1,1,1), vec(5,6,2,2));
    root.doors ~= Door(1, [3,0,1,1], Door.Type.normal);
    root.doors ~= Door(0, [0,3,1,1], Door.Type.normal);
    root.doors ~= Door(1, [2,6,1,1], Door.Type.normal);

    auto w = new World;
    w.map.tree = root;

    // Ladder placement should use interior, not bounding region.
    w.map.bounds = region(vec(0,0,0,0), vec(9,9,9,9));

    w.map.waterLevel = int.max;

    addLadders(w, w.map.tree, w.map.bounds);

    bool hasLadder(Pos pos)
    {
        return w.getAllAt(pos)
                .canFind!(id => w.store.get!Tiled(id).tileId == TileId.ladder);
    }

    assert(!hasLadder(Pos(0,1,1,1)));
    assert(!hasLadder(Pos(1,1,1,1)));
    assert(!hasLadder(Pos(2,1,1,1)));
    assert(!hasLadder(Pos(3,1,1,1)));
    assert(!hasLadder(Pos(4,1,1,1)));
    assert(!hasLadder(Pos(5,1,1,1)));

    assert( hasLadder(Pos(0,3,1,1)));
    assert( hasLadder(Pos(1,3,1,1)));
    assert( hasLadder(Pos(2,3,1,1)));
    assert( hasLadder(Pos(3,3,1,1)));
    assert( hasLadder(Pos(4,3,1,1)));
    assert(!hasLadder(Pos(5,3,1,1)));

    assert(!hasLadder(Pos(0,5,1,1)));
    assert(!hasLadder(Pos(1,5,1,1)));
    assert(!hasLadder(Pos(2,5,1,1)));
    assert( hasLadder(Pos(3,5,1,1)));
    assert( hasLadder(Pos(4,5,1,1)));
    assert(!hasLadder(Pos(5,5,1,1)));
}

/**
 * Randomly assign room floors.
 */
void setRoomFloors(R)(MapNode root, R bounds)
    if (is(R == Region!(int,n), size_t n))
{
    foreachRoom(root, bounds, (R r, MapNode node) {
        import std.random : uniform;
        auto x = uniform(0, 100);
        node.style = (x < 50) ? FloorStyle.bare :
                     (x < 80) ? FloorStyle.grassy :
                                FloorStyle.muddy;
        return 0;
    });
}

unittest
{
    import testutil;
    enum wd = 48, ht = 24;
    auto result = TestScreen!(wd,ht)();

    import std.algorithm : filter, clamp;
    import std.random : uniform;
    import std.range : iota;
    import rndutil;

    // Generate base BSP tree
    auto bounds = region(vec(1, 1, 0, 0), vec(wd, ht, 2, 2));
    alias R = typeof(bounds);

    auto tree = genBsp!MapNode(bounds,
        (R r) => r.length(0)*r.length(1) > 49 + uniform(0, 50),
        (R r) => iota(4).filter!(i => r.max[i] - r.min[i] > 8)
                        .pickOne(invalidAxis),
        (R r, int axis) => (r.max[axis] - r.min[axis] < 8) ?
            invalidPivot : uniform(r.min[axis]+4, r.max[axis]-3)
            //gaussian(r.max[axis] - r.min[axis], 4)
            //    .clamp(r.min[axis] + 3, r.max[axis] - 3)
    );

    auto w = new World;
    w.map.tree = tree;
    w.map.bounds = bounds;

    // Generate connecting corridors
    setRoomInteriors(w.map.tree, w.map.bounds);
    genCorridors(w.map.tree, w.map.bounds);
    assert(doorsSanityCheck(w));

    // Generate back edges
    genBackEdges!R(w.map.tree, w.map.bounds, 4, 15,
        (in MapNode[2] rooms, ref Door d) {
            d.type = Door.Type.extra;
            return true;
        },
        (MapNode node, R region) => uniform(0, 2), false
    );
    assert(doorsSanityCheck(w));

    resizeRooms(w.map.tree, w.map.bounds, 3);
    assert(doorsSanityCheck(w));

    setRoomFloors(w.map.tree, w.map.bounds);

    version(none)
    {
        dumpBsp(result, w.map.tree, w.map.bounds);
        assert(0);
    }
}

unittest
{
    import testutil;
    enum wd = 20, ht = 12;
    auto result = TestScreen!(wd,ht)();

    import std.algorithm : filter, clamp;
    import std.random : uniform;
    import std.range : iota;
    import rndutil;

    // Generate base BSP tree
    auto bounds = region(vec(1, 1, 0, 0), vec(wd, ht, 2, 2));
    alias R = typeof(bounds);

    TreeGenArgs args;
    args.splitVolume = ValRange(50, 200);
    args.minNodeDim = 2;
    auto tree = genTree(bounds, args);

    auto w = new World;
    w.map.tree = tree;
    w.map.bounds = bounds;
    assert(doorsSanityCheck(w));

    // Generate back edges
    genBackEdges!R(w.map.tree, w.map.bounds, 4, 15,
        (in MapNode[2] rooms, ref Door d) {
            d.type = Door.Type.extra;
            return true;
        },
        (MapNode node, R region) => uniform(0, 2), false
    );
    assert(doorsSanityCheck(w));

    resizeRooms(w.map.tree, w.map.bounds, args.minNodeDim-1);
    assert(doorsSanityCheck(w));

    setRoomFloors(w.map.tree, w.map.bounds);

    version(none)
    {
        dumpBsp(result, w.map.tree, w.map.bounds);
        assert(0);
    }
}

/**
 * Returns: A random room in the given BSP tree that's completely above the
 * water level, null if all rooms are submerged (or partially so).
 *
 * Prerequisites: Room .interior's must have been set.
 */
MapNode randomDryRoom(MapNode tree, Region!(int,4) bounds, int waterLevel)
    out(node; node is null || node.isLeaf())
{
    auto dryRegion = bounds;
    dryRegion.max[0] = waterLevel;

    MapNode dryRoom;
    int n = 0;
    foreachFiltRoom(tree, bounds, dryRegion,
        (MapNode node, Region!(int,4) r) {
            if (node.interior.max[0] > waterLevel)
                return 0; // reject partially-submerged rooms

            if (n == 0 || uniform(0, n) == 0)
            {
                dryRoom = node;
            }
            n++;
            return 0;
        }
    );
    return dryRoom;
}

unittest
{
    auto bounds = region(vec(0,0,0,0), vec(10,5,5,5));
    auto root = new MapNode;
    root.axis = 0;
    root.pivot = 5;

    root.left = new MapNode;
    root.left.interior = region(vec(0,0,0,0), vec(4,4,4,4));

    root.right = new MapNode;
    root.right.interior = region(vec(5,0,0,0), vec(9,4,4,4));

    assert(randomDryRoom(root, bounds, 8) is root.left);
    assert(randomDryRoom(root, bounds, 5) is root.left);
    assert(randomDryRoom(root, bounds, 4) is root.left);
    assert(randomDryRoom(root, bounds, 3) is null);
}

/**
 * Returns: A random floor location in the given BSP tree that's above the
 * water level.
 */
Vec!(int,4) randomDryPos(MapNode tree, Region!(int,4) bounds, int waterLevel)
{
    auto dryRoom = randomDryRoom(tree, bounds, waterLevel);
    return dryRoom.randomLocation(dryRoom.interior);
}

unittest
{
    auto bounds = region(vec(0,0,0,0), vec(10,5,5,5));
    auto root = new MapNode;
    root.axis = 0;
    root.pivot = 5;

    root.left = new MapNode;
    root.left.interior = region(vec(0,0,0,0), vec(4,4,4,4));

    root.right = new MapNode;
    root.right.interior = region(vec(5,0,0,0), vec(9,4,4,4));

    auto pos = randomDryPos(root, bounds, 7);
    assert(root.left.interior.contains(pos));
}

/**
 * Generate pits and pit traps.
 *
 * Params:
 *  w = The game world.
 *  count = The number of pit traps to attempt to place. Note that the actual
 *      number of traps generated may be lower than this, if there are too many
 *      failed attempts to find suitable locations for traps.
 *  openPitPct = Percentage of pits that will be visible open pits, vs. hidden
 *      traps.
 */
void genPitTraps(World w, MapNode tree, Region!(int,4) bounds, int count,
                 int openPitPct = 30)
{
    genBackEdges(tree, bounds, count, count*8,
        (in MapNode[2] rooms, ref Door d) {
            assert(d.axis == 0);

            bool nextToExisting;
            foreach (rm; rooms)
            {
                foreach (dd; rm.doors)
                {
                    if (dd.type == Door.Type.normal &&
                        iota(4).map!(i => abs(d.pos[i] - dd.pos[i])).sum == 1)
                    {
                        nextToExisting = true;
                    }

                    if (dd.axis != 0 &&
                        iota(1, 4).map!(i => abs(d.pos[i] - dd.pos[i]))
                                  .sum == 1)
                    {
                        // Don't place where a ladder would be placed.
                        return false;
                    }
                }
            }

            if (!nextToExisting && uniform(0, 100) < openPitPct)
            {
                // Non-hidden open pit.
                d.type = Door.Type.extra;
            }
            else
            {
                d.type = Door.Type.trapdoor;
                auto floorId = style2Terrain(rooms[0].style);
                w.store.createObj(Pos(vec(d.pos) + vec(-1,0,0,0)),
                                  Trigger(Trigger.Type.onEnter, w.triggerId));
                w.store.createObj(Pos(d.pos), Name("pit trap"),
                    Tiled(TileId.wall, -1), *w.store.get!TiledAbove(floorId),
                    BlocksMovement(Climbable.yes), BlocksView(),
                    Triggerable(w.triggerId, TriggerEffect.trapDoor),
                    SupportsWeight(SupportType.above));
                w.triggerId++;
            }
            return true;
        },
        (MapNode node, Region!(int,4) bounds) => 0, // always pick vertical
        true,   // allow multiple pit traps on same wall as normal door
    );
}

unittest
{
    // Test case:
    //   01234
    // 0 #####
    // 1 #   #
    // 2 ##X##
    // 3 #   #
    // 4 #   #
    // 5 #####
    auto bounds = region(vec(0,0,0,0), vec(6,5,2,2));
    auto root = new MapNode;
    root.axis = 0;
    root.pivot = 3;

    root.left = new MapNode;
    root.left.interior = region(vec(1,1,0,0), vec(2,4,1,1));
    root.left.style = FloorStyle.grassy;

    root.right = new MapNode;
    root.right.interior = region(vec(3,1,0,0), vec(5,4,1,1));
    root.right.style = FloorStyle.muddy;

    auto w = new World;
    w.map.tree = root;
    w.map.bounds = bounds;

    genPitTraps(w, root, bounds, 1, 0);

    auto r = w.store.getAll!Triggerable()
                    .map!(id => w.store.get!TiledAbove(id));
    assert(!r.empty);
    assert(r.front.tileId == TileId.floorGrassy);
}

/**
 * Generate rock traps.
 *
 * Prerequisites:
 * - Must be called *after resizeRooms(), addLadders(), setting of water
 *   levels, and placement of important level objects like portals, because
 *   this will generate traps on any unoccupied floor tile. (But it's probably
 *   OK to call this before placing gold, monsters, or other items: it will
 *   just be trapped gold. :-P)
 *
 * Note: this is done separately from genPitTraps because it needs rooms'
 * .interior to be already fixed.
 *
 * BUGS: Unfortunately, this function is not 100% World-agnostic; it requires
 * w.map to be initialized otherwise it will crash.
 */
void genRockTraps(World w, MapNode tree, Region!(int,4) bounds, int count)
{
    OUTER: while (count > 0)
    {
        // Find unoccupied location.
        auto room = randomDryRoom(tree, bounds, w.map.waterLevel);
        if (room is null)
            return; // everything is underwater; don't bother.

        auto pos = room.randomLocation(room.interior);
        auto floorPos = pos + vec(1,0,0,0);
        auto nTries = room.floorArea;
        while (!w.store.getAllBy!Pos(Pos(pos)).empty ||
               !w.locationHas!BlocksMovement(floorPos) ||
               room.doors.canFind!(d => iota(1, 4)
                                        .map!(i => abs(d.pos[i] - pos[i]))
                                        .sum <= 1))
        {
            pos = room.randomLocation(room.interior);
            floorPos = pos + vec(1,0,0,0);

            if (--nTries <= 0)
                continue OUTER; // insure against infinite loop
        }

        auto ceilingPos = pos;
        ceilingPos[0] = room.interior.min[0];
        pos[0] = room.interior.max[0] - 1;

        createRockTrapTrig(&w.store, pos, w.triggerId);
        createRockTrap(&w.store, ceilingPos, w.triggerId);
        w.triggerId++;
        count--;
    }
}

unittest
{
    // Unfortunately this is probabilistic; so to catch potential violations we
    // need to repeat it a few times.
    foreach (_; 0 .. 5)
    {
        auto root = new MapNode;
        root.interior = region(vec(1,1,1,1), vec(3,3,3,3));
        root.doors = [
            Door(2, [1,1,0,1]),
            Door(3, [2,1,2,0]),
            Door(3, [2,1,1,3]),
            Door(0, [0,2,1,1]),
            Door(1, [2,3,2,1]),
        ];

        auto w = new World;
        w.map.tree = root;
        w.map.bounds = region(vec(0,0,0,0), vec(4,4,4,4));
        w.map.waterLevel = int.max;

        w.store.createObj(Pos(2,2,1,2), Name("blocker"));
        w.store.createObj(Pos(2,2,2,2), Name("blocker"));

        while (w.triggerId < 1)
            genRockTraps(w, w.map.tree, w.map.bounds, 1);

        import std.format : format;
        auto r = w.store.getAll!Triggerable()
                        .map!(id => w.store.get!Pos(id));
        assert(!r.empty);
        assert(r.front !is null && *r.front == Pos(1,1,2,2),
               format("%s", *r.front));
    }
}

/**
 * Locates the neighbour of the given node connected by the given door.
 */
MapNode findNgbr(R)(MapNode tree, R bounds, MapNode node, uint doorIdx)
    in (doorIdx < node.doors.length)
{
    // Compute coordinates of the other side of the door.
    auto d = node.doors[doorIdx];
    auto otherSide = vec(d.pos);
    otherSide[d.axis] += (d.pos[d.axis] == node.interior.max[d.axis]) ? 1 : -1;

    MapNode ngbr;
    Region!(int,4) ngbrBounds;
    foreachFiltRoom(tree, bounds, (R r) => r.contains(otherSide),
                    (MapNode n, R r1) {
                        assert(ngbr is null);
                        ngbr = n;
                        ngbrBounds = r1;
                        return 1;
                    });

    return ngbr;
}

unittest
{
    //   0123456789
    // 0 ##########
    // 1 #   #    #
    // 2 #   #    #
    // 3 ##|##    #
    // 4 #   -    #
    // 5 #   #    #
    // 6 ##########
    auto root = new MapNode;
    root.axis = 2;
    root.pivot = 5;

    root.left = new MapNode;
    root.left.axis = 3;
    root.left.pivot = 4;
    root.left.left = new MapNode;
    root.left.left.doors ~= Door(3, [ 1, 1, 2, 3 ]);
    root.left.right = new MapNode;
    root.left.right.doors ~= Door(3, [ 1, 1, 2, 3 ]);
    root.left.right.doors ~= Door(2, [ 1, 1, 4, 4 ]);

    root.right = new MapNode;
    root.right.doors ~= Door(2, [ 1, 1, 4, 4 ]);

    auto bounds = region(vec(0,0,1,1), vec(2,2,10,7));
    setRoomInteriors(root, bounds);

    assert(findNgbr(root, bounds, root.right, 0) == root.left.right);
    assert(findNgbr(root, bounds, root.left.right, 0) == root.left.left);
    assert(findNgbr(root, bounds, root.left.right, 1) == root.right);
    assert(findNgbr(root, bounds, root.left.left, 0) == root.left.right);
}

/**
 * Adjusts doors heights to be flush against the highest floor they connect, so
 * that we avoid unnecessary ladders.
 */
void sinkDoors(MapNode tree, Region!(int,4) region)
{
    foreachRoom(tree, region, (Region!(int,4) bounds, MapNode node)
    {
        foreach (i, ref d; node.doors)
        {
            if (d.axis == 0) continue;
            auto ngbr = findNgbr(tree, region, node, cast(uint) i);
            if (ngbr is null) continue;
            auto upperFloor = min(node.interior.max[0], ngbr.interior.max[0]);
            d.pos[0] = upperFloor - 1;
        }
        return 0;
    });
}

unittest
{
    //   0123456789
    // 0 ##########
    // 1 #3  #4   #
    // 2 #   #    #
    // 3 ##|##    #
    // 4 #5  -    #
    // 5 #   #    #
    // 6 ##########
    auto root = new MapNode;
    root.axis = 2;
    root.pivot = 5;

    root.left = new MapNode;
    root.left.axis = 3;
    root.left.pivot = 4;
    root.left.left = new MapNode;
    root.left.left.doors ~= Door(3, [ 1, 1, 2, 3 ]);
    root.left.right = new MapNode;
    root.left.right.doors ~= Door(3, [ 1, 1, 2, 3 ]);
    root.left.right.doors ~= Door(2, [ 1, 1, 4, 4 ]);

    root.right = new MapNode;
    root.right.doors ~= Door(2, [ 1, 1, 4, 4 ]);

    auto bounds = region(vec(0,0,1,1), vec(5,2,10,7));
    setRoomInteriors(root, bounds);

    // Set floor heights
    root.left.left.interior.max[0] = 3;
    root.left.right.interior.max[0] = 5;
    root.right.interior.max[0] = 4;

    auto w = new World;
    w.map.tree = root;
    w.map.bounds = bounds;

    sinkDoors(w.map.tree, w.map.bounds);

    assert(root.left.left.doors == [
        Door(3, [ 2, 1, 2, 3 ]),
    ]);
    assert(root.left.right.doors == [
        Door(3, [ 2, 1, 2, 3 ]),
        Door(2, [ 3, 1, 4, 4 ]),
    ]);
    assert(root.right.doors == [
        Door(2, [ 3, 1, 4, 4 ]),
    ]);
}

/**
 * Places an exit portal.
 */
void genPortal(World w, MapNode tree, Region!(int,4) bounds)
{
    // Pick a tile that isn't empty or has no floor support.
    auto pos = randomDryPos(tree, bounds, w.map.waterLevel);
    while (!w.store.getAllBy!Pos(Pos(pos)).empty ||
           !w.locationHas!BlocksMovement(pos + vec(1,0,0,0)))
        pos = randomDryPos(tree, bounds, w.map.waterLevel);

    createPortal(&w.store, pos);
}

unittest
{
    auto node = new MapNode;
    node.interior = region(vec(0,0,0,0), vec(2,2,1,1));
    node.doors = [ Door(0, [2,0,0,0], Door.Type.trapdoor) ];

    auto w = new World;
    w.map.tree = node;
    w.map.bounds = region(vec(0,0,0,0), vec(3,3,2,2));
    w.map.waterLevel = int.max;

    foreach (_; 0 .. 10)
    {
        genPortal(w, w.map.tree, w.map.bounds);

        auto r = w.store.getAll!Usable();
        assert(!r.empty);
        auto id = r.front;
        auto pos = *w.store.get!Pos(id);
        assert(pos == Pos(1,1,0,0));

        r.popFront;
        assert(r.empty);

        w.store.destroyObj(id);
    }
}

/**
 * A random variable bounded by a range.
 */
struct ValRange
{
    int min, max=1;
    int pick() { return uniform(min, max); }

    unittest
    {
        ValRange v;
        assert(v.pick == 0);
    }
}

/**
 * Map generation parameters.
 */
struct TreeGenArgs
{
    /**
     * Nodes with this volume or greater will be considered for splitting.
     *
     * Note that the ValRange is evaluated once per node; so the lower bound
     * essentially acts as a minimum volume before a node will be split, and
     * the upper bound gives a probability of when a large node up to that size
     * will not be split.
     */
    ValRange splitVolume = ValRange(25, 105);

    /**
     * Minimum length of a node along each axis. A candidate split will be
     * rejected if it would result in a node that has a dimension smaller than
     * this length.  This effectively means nodes of less than 2*minNodeDim
     * along an axis would not be split along that axis (its other axes may
     * still split, though).
     *
     * Note that this must also include space for walls if the node is to be
     * made into a room; so this value should be ≥2 (which would result in a
     * narrow corridor), or ≥3 if narrow corridors are not wanted.
     */
    int minNodeDim = 4;
}

struct MapGenArgs
{
    TreeGenArgs tree;
    ValRange nBackEdges;
    ValRange nPitTraps;
    ValRange nRockTraps;

    float goldPct;
    float rockPct = 2.0, sharpRockPct = 5.0;
    ValRange waterLevel = ValRange(int.max-1, int.max);
    ValRange nMonstersA;
    ValRange nMonstersC;
    ValRange nCrabShells;
    ValRange nScubas;

    bool sinkDoors = true;
}

/**
 * Generate raw level geometry.
 *
 * NOTE: May return null if bounds are too small to generate geometry that
 * satisfies map constraints.
 */
MapNode genTree(Region!(int,4) bounds, TreeGenArgs args)
{
    enum nRetries = 10;
    alias R = Region!(int,4);

    auto splitLen = args.minNodeDim * 2;

    MapNode tree;
    foreach (_; 0 .. nRetries)
    {
        tree = genBsp!MapNode(bounds,
            (R r) => r.volume > args.splitVolume.pick,
            (R r) => iota(4).filter!(i => r.max[i] - r.min[i] >= splitLen)
                            .pickOne(invalidAxis),
            (R r, int axis) => (r.max[axis] - r.min[axis] < splitLen) ?
                invalidPivot : uniform(r.min[axis] + args.minNodeDim,
                                       r.max[axis] - args.minNodeDim + 1)
        );

        setRoomInteriors(tree, bounds);
        try
        {
            genCorridors(tree, bounds);
            break;
        }
        catch (GenCorridorsException e)
        {
            // This tree can't be properly connected; try again with a
            // different tree.
            tree = null;
            //version(none)
            {
                import std.stdio;
                writefln("genCorridors failed (%s), retrying", e.msg);
            }
        }
    }

    return tree;
}

/**
 * Phase 2 of level geometry generation.
 */
void genGeometry(World w, MapNode tree, Region!(int,4) bounds, MapGenArgs args)
{
    setRoomFloors(tree, bounds);

    // Add back edges, regular and pits/pit traps.
    genBackEdges(tree, bounds, args.nBackEdges.pick,
                 args.nBackEdges.max + 15);
    genPitTraps(w, tree, bounds, args.nPitTraps.pick);

    resizeRooms(tree, bounds, args.tree.minNodeDim - 1);
    if (args.sinkDoors)
        sinkDoors(tree, bounds);
}

void genObjects(World w, MapNode tree, Region!(int,4) bounds, MapGenArgs args,
                MapNode startRoom = null)
{
    addLadders(w, tree, bounds);
    genRockTraps(w, tree, bounds, args.nRockTraps.pick);

    // Items
    foreach (i; 0 .. args.nCrabShells.pick())
    {
        auto pos = randomLocation(tree, bounds);
        createCrabShell(&w.store, Pos(pos));
    }

    foreach (i; 0 .. args.nScubas.pick())
    {
        auto pos = randomDryPos(tree, bounds, w.map.waterLevel);
        createScuba(&w.store, Pos(pos));
    }

    // Generate random rocks as additional deco.
    auto mapFloorArea = floorArea(tree);
    foreach (i; 0 .. mapFloorArea * args.rockPct / 100)
    {
        auto pos = randomLocation(tree, bounds);
        if (uniform(0, 100) < args.sharpRockPct)
            createSharpRock(&w.store, pos);
        else
            createRock(&w.store, pos);
    }

    // Generate random vegetation for creatures to seek out once in a while.
    enum vegPct = 8; // FIXME: should be configurable
    enum vegDensePct = 15;
    foreach (i; 0 .. mapFloorArea * vegPct / 100)
    {
        // TBD: bias the distribution to be closer to water line, fade away
        // farther away from water line.
        if (uniform(0, 100) < vegDensePct)
            createDenseVeg(&w.store, randomLocation(tree, bounds));
        else
            createVeg(&w.store, randomLocation(tree, bounds));
    }

    // Note: this should be done after all other items / deco, so that it
    // doesn't get obscured!
    auto ngold = cast(int)(mapFloorArea * args.goldPct / 100);
    foreach (i; 0 .. ngold)
    {
        createGold(&w.store, randomLocation(tree, bounds));
    }

    foreach (i; 0 .. args.nMonstersA.pick())
    {
        auto pos = randomLocation(tree, bounds);

        // Avoid placing monsters in player's starting room.
        while (startRoom && startRoom.interior.contains(pos))
            pos = randomDryPos(tree, bounds, w.map.waterLevel);

        createMonsterA(&w.store, pos);
    }

    foreach (i; 0 .. args.nMonstersC.pick())
    {
        auto pos = randomLocation(tree, bounds);

        // Avoid placing monsters in player's starting room.
        while (startRoom && startRoom.interior.contains(pos))
            pos = randomLocation(tree, bounds);

        createMonsterC(&w.store, pos);
    }
}

/**
 * Generate new game world using the BSP tree algorithm.
 */
World genBspLevel(Region!(int,4) bounds, MapGenArgs args, out int[4] startPos)
{
    auto w = new World;

    // Generate level geometry
    w.map.waterLevel = args.waterLevel.pick;
    w.map.tree = genTree(bounds, args.tree);
    if (w.map.tree is null)
        throw new Exception("Unable to generate map");
    w.map.bounds = bounds;
    genGeometry(w, w.map.tree, bounds, args);

    // Place starting position and exit.
    MapNode startRoom = randomDryRoom(w.map.tree, w.map.bounds,
                                      w.map.waterLevel);
    startPos = startRoom.randomLocation(startRoom.interior);
    genPortal(w, w.map.tree, w.map.bounds);

    // Add objects and deco.
    genObjects(w, w.map.tree, w.map.bounds, args, startRoom);

    return w;
}

// Mapgen sanity tests.
unittest
{
    foreach (i; 0 .. 12)
    {
        int[4] startPos;
        MapGenArgs args;
        auto bounds = region(vec(0,0,0,0), vec(10,10,10,10));
        auto w = genBspLevel(bounds, args, startPos);

        // Door placement checks.
        foreachRoom(w.map.tree, w.map.bounds,
            (Region!(int,4) region, MapNode node) {
                foreach (i; 0 .. node.doors.length-1)
                {
                    auto d1 = node.doors[i];
                    auto pos1 = d1.pos;
                    foreach (j; i+1 .. node.doors.length)
                    {
                        auto d2 = node.doors[j];
                        auto pos2 = d2.pos;

                        // No coincident doors.
                        assert(pos1 != pos2);

                        // Only trapdoors/pits are allowed to be adjacent to
                        // another door.
                        if (iota(4).map!(i => abs(pos1[i] - pos2[i])).sum == 1)
                        {
                            assert(d1.type != Door.Type.normal ||
                                   d2.type != Door.Type.normal);
                        }
                    }

                    // Trapdoors & pits not allowed where ladders would be
                    // placed.
                    if (d1.type != Door.Type.normal)
                    {
                        foreach (j; 0 .. node.doors.length)
                        {
                            auto d2 = node.doors[j];
                            auto pos2 = d2.pos;

                            if (i == j || d2.axis == 0)
                                continue;

                            assert(iota(1,4).map!(i => abs(pos1[i] - pos2[i]))
                                            .sum != 1);
                        }
                    }
                }
                return 0;
            }
        );

        // Water level tests.
        import std.format : format;
        assert(startPos[0] < w.map.waterLevel,
               format("startPos %s below water level %d", startPos,
                      w.map.waterLevel));
        foreach (pos; w.store.getAll!Usable()
                       .filter!(id => w.store.get!Usable(id).effect ==
                                      UseEffect.portal)
                       .map!(id => w.store.get!Pos(id))
                       .filter!(posp => posp !is null)
                       .map!(posp => *posp))
        {
            assert(pos[0] < w.map.waterLevel,
                   format("Portal %s below water level %d", pos,
                          w.map.waterLevel));
        }
    }
}

/**
 * Generate tutorial level.
 *
 * For now, this returns a hard-coded level.  Later on we can extend this to
 * have more randomized elements.
 */
World genTutorialLevel(out int[4] startPos)
{
    auto w = new World;

    // Auto-generated by bspbuild. You probably don't want to edit this by
    // hand. :-D
    auto tree = new MapNode;
    tree.axis = 0;
    tree.pivot = 1;
    tree.left = new MapNode;
    tree.left.axis = 1;
    tree.left.pivot = 1;
    tree.left.left = new MapNode;
    tree.left.left.axis = 2;
    tree.left.left.pivot = 1;
    tree.left.left.left = new MapNode;
    tree.left.left.left.interior = region(vec(0,0,0,0), vec(1,1,1,5));
    tree.left.left.right = new MapNode;
    tree.left.left.right.axis = 3;
    tree.left.left.right.pivot = 4;
    tree.left.left.right.left = new MapNode;
    tree.left.left.right.left.interior = region(vec(0,0,3,0), vec(1,1,4,1));
    tree.left.left.right.right = new MapNode;
    tree.left.left.right.right.interior = region(vec(0,0,1,4), vec(1,1,5,5));
    tree.left.right = new MapNode;
    tree.left.right.axis = 2;
    tree.left.right.pivot = 2;
    tree.left.right.left = new MapNode;
    tree.left.right.left.axis = 1;
    tree.left.right.left.pivot = 4;
    tree.left.right.left.left = new MapNode;
    tree.left.right.left.left.interior = region(vec(0,3,0,0), vec(1,4,1,5));
    tree.left.right.left.right = new MapNode;
    tree.left.right.left.right.interior = region(vec(0,4,0,0), vec(1,5,2,1));
    tree.left.right.right = new MapNode;
    tree.left.right.right.axis = 3;
    tree.left.right.right.pivot = 2;
    tree.left.right.right.left = new MapNode;
    tree.left.right.right.left.axis = 1;
    tree.left.right.right.left.pivot = 4;
    tree.left.right.right.left.left = new MapNode;
    tree.left.right.right.left.left.interior = region(vec(0,1,3,0), vec(1,4,4,1));
    tree.left.right.right.left.right = new MapNode;
    tree.left.right.right.left.right.interior = region(vec(0,4,2,0), vec(1,5,4,1));
    tree.left.right.right.right = new MapNode;
    tree.left.right.right.right.axis = 2;
    tree.left.right.right.right.pivot = 4;
    tree.left.right.right.right.left = new MapNode;
    tree.left.right.right.right.left.interior = region(vec(0,4,2,2), vec(1,5,4,3));
    tree.left.right.right.right.right = new MapNode;
    tree.left.right.right.right.right.interior = region(vec(0,1,4,4), vec(1,5,5,5));
    tree.right = new MapNode;
    tree.right.axis = 2;
    tree.right.pivot = 1;
    tree.right.left = new MapNode;
    tree.right.left.axis = 0;
    tree.right.left.pivot = 2;
    tree.right.left.left = new MapNode;
    tree.right.left.left.axis = 1;
    tree.right.left.left.pivot = 4;
    tree.right.left.left.left = new MapNode;
    tree.right.left.left.left.interior = region(vec(1,3,0,0), vec(2,4,1,5));
    tree.right.left.left.right = new MapNode;
    tree.right.left.left.right.interior = region(vec(1,4,0,4), vec(2,5,1,5));
    tree.right.left.right = new MapNode;
    tree.right.left.right.axis = 3;
    tree.right.left.right.pivot = 1;
    tree.right.left.right.left = new MapNode;
    tree.right.left.right.left.interior = region(vec(2,4,0,0), vec(4,5,1,1));
    tree.right.left.right.right = new MapNode;
    tree.right.left.right.right.interior = region(vec(2,4,0,1), vec(3,5,1,5));
    tree.right.right = new MapNode;
    tree.right.right.axis = 1;
    tree.right.right.pivot = 4;
    tree.right.right.left = new MapNode;
    tree.right.right.left.interior = region(vec(3,0,1,1), vec(5,3,4,4));
    tree.right.right.right = new MapNode;
    tree.right.right.right.axis = 2;
    tree.right.right.right.pivot = 4;
    tree.right.right.right.left = new MapNode;
    tree.right.right.right.left.axis = 3;
    tree.right.right.right.left.pivot = 2;
    tree.right.right.right.left.left = new MapNode;
    tree.right.right.right.left.left.interior = region(vec(2,4,1,0), vec(4,5,4,1));
    tree.right.right.right.left.right = new MapNode;
    tree.right.right.right.left.right.interior = region(vec(1,4,2,2), vec(5,5,3,3));
    tree.right.right.right.right = new MapNode;
    tree.right.right.right.right.axis = 3;
    tree.right.right.right.right.pivot = 4;
    tree.right.right.right.right.left = new MapNode;
    tree.right.right.right.right.left.interior = region(vec(3,4,4,0), vec(5,5,5,4));
    tree.right.right.right.right.right = new MapNode;
    tree.right.right.right.right.right.interior = region(vec(1,4,4,4), vec(5,5,5,5));

    startPos = [0,0,0,0];

    w.map.tree = tree;
    w.map.bounds = region(vec(0,0,0,0), vec(6,6,6,6));
    w.map.waterLevel = int.max;

    // FIXME: this should be autogen'd
    void addDoor(Vec!(int,4) pos)
    {
        alias R = Region!(int,4);
        foreachFiltRoom(tree, w.map.bounds, (R r) => r.contains(pos),
            (MapNode node, R r) {
                node.doors ~= Door(3, pos[]);
                return 0;
            }
        );
    }
    addDoor(vec(0,4,3,1));
    addDoor(vec(4,3,2,2));

    // FIXME: this should be autogen'd too.
    foreach (i; 1 .. 5)
    {
        createLadder(&w.store, Pos(i, 4, 4, 4));
    }

    auto doorTrigId = w.triggerId++;
    w.store.createObj(Pos(0,4,3,1), Tiled(TileId.lockedDoor, -2),
                      Name("locked door"), BlocksMovement(),
                      Triggerable(doorTrigId, TriggerEffect.toggleDoor));
    w.store.createObj(Pos(0,0,3,0), Name("lever"), Tiled(TileId.lever1),
                      Usable(UseEffect.trigger, "pull", doorTrigId));

    // Put some gold for the player to collect.
    enum goldPos = [
        Pos(4,0,1,1),
        Pos(4,0,1,3),
        Pos(4,0,3,1),
        Pos(4,0,3,3),
        Pos(4,2,1,1),
        Pos(4,2,1,3),
        Pos(4,2,3,1),
        Pos(4,2,3,3),
    ];
    foreach (pos; goldPos)
    {
        createGold(&w.store, pos);
    }

    // Some in-game instructions to guide the player along.
    w.store.createObj(Pos(0,0,0,0), Message([
        "This is the tutorial training area.",
        "Use the 'j' and 'k' keys to move left/right.",
    ]));
    w.store.createObj(Pos(0,0,0,4), Message([
        "Good!",
        "Now use the 'n' and 'o' keys to move forwards/backwards.",
    ]));
    w.store.createObj(Pos(0,0,4,4), Message([
        "Very good!",
        "Next, use the 'h' and 'l' keys to move ana/kata.",
    ]));
    w.store.createObj(Pos(0,4,4,4), Message([
        "Excellent!",
        "Use the 'i' and 'm' keys to climb up/down.",
    ]));
    w.store.createObj(Pos(4,4,4,4), Message([
        "Now walk to the end of the corridor.",
    ]));
    w.store.createObj(Pos(4,4,4,0), Message([
        "There's a ledge here that you can climb.",
        "To climb up, move in its direction with 'o'.",
    ]));
    w.store.createObj(Pos(3,4,0,0), Message([
        "There's another ledge on the right.",
        "To climb up, move in its direction with 'k'.",
    ]));
    w.store.createObj(Pos(2,4,0,4), Message([
        "There's a ledge ana of here.",
        "To climb up, move in its direction with 'h'.",
    ]));
    w.store.createObj(Pos(1,3,0,4), Message([
        "Good job!",
        "Ana/kata ledges are easy to miss.",
        "Always be sure to check for them.",
    ]));
    w.store.createObj(Pos(1,3,0,0), Message([
        "Do you see the next ledge?",
        "It's kata of here.",
        "Use 'l' to climb on it.",
    ]));
    w.store.createObj(Pos(0,4,3,0), Message([
        "There's a locked door on the right.",
        "To open it, you need to find the switch.",
        "Try looking in the corridor ana of here.",
        "Use the 'h' key.",
    ]), Triggerable(doorTrigId, TriggerEffect.removeMsg));

    w.store.createObj(Pos(0,0,3,0), Message([
        "You found the switch!",
        "Activate it with the Enter key.",
    ]));
    w.store.createObj(Pos(0,4,3,2), Message([
        "The blank space ahead is a hole.",
        "Walking onto it will cause you to fall down.",
        "Don't worry, you won't get hurt.",
        "Go ahead and try it with 'o'."
    ]));

    auto fallMsgTrig = w.triggerId++;
    w.store.createObj(Pos(4,4,2,2), Message([
        "See? That didn't hurt, did it?",
    ]), Triggerable(fallMsgTrig, TriggerEffect.removeMsg));
    w.store.createObj(Pos(4,3,2,2),
                      Trigger(Trigger.Type.onEnter, fallMsgTrig));

    w.store.createObj(Pos(4,3,2,2), Message([
        "To finish up, collect all the gold in the room.",
        "You can collect them just by walking on them.",
        "After collecting them all, go to the exit portal.",
        "Press '?' any time for help with movement keys.",
    ]));

    // An exit portal to end the tutorial.
    w.store.createObj(Pos(4,1,2,2), Tiled(TileId.portal), Name("exit portal"),
                      Usable(UseEffect.portal, "activate"),
                      Message([
                        "This is the exit portal.",
                        "Press Enter to activate it."
                      ]));

    return w;
}

version(none) // level gen stress test
unittest
{
    import std.stdio;
    MapGenArgs args;
    auto bounds = region(vec(0,0,0,0), vec(64,64,64,64));
    args.nBackEdges = ValRange(20, 50);
    args.nPitTraps = ValRange(50, 80);
    args.goldPct = 0.2;
    args.waterLevel = ValRange(16, 64);
    args.nMonstersA = ValRange(20, 30);

    foreach (i; 0 .. 50)
    {
        int[4] startPos;
        World w;
        for (;;)
        {
            try {
                w = genBspLevel(bounds, args, startPos);
                assert(doorsSanityCheck(w));
                break;
            } catch (Exception e) {
                writefln("[%d] oops: %s", i, e.msg);
            }
        }
        if (w is null)
            writefln("[%d] WAT?!", i);
        else
            writefln("[%d] %d gold", i, w.store.getAll!QuestItem().count);
    }
}

/**
 * Parameters for bipartite level generation.
 */
struct BipartiteGenArgs
{
    Region!(int,4) region;
    ValRange axis;
    ValRange pivot;
    ValRange waterLevel = ValRange(int.max-1, int.max);
    bool sinkDoor = true;

    int startPart;
    int portalPart;

    MapGenArgs[2] subargs;
}

/**
 * Generate a bipartite level with potentially different generation parameters
 * for each part, connected by a single door(way) that may be made a locking
 * door, etc..
 *
 * Params:
 *  args = The level generation parameters.
 */
World genBipartiteLevel(BipartiteGenArgs args,
                        out int[4] startPos,
                        out int[4] doorPos,
                        out Region!(int,4) boundsLeft,
                        out Region!(int,4) boundsRight)
{
    auto axis = args.axis.pick;
    auto pivot = args.pivot.pick;

    // Two halves of a map with distinct parameters.
    boundsLeft = args.region;
    boundsLeft.max[axis] = pivot;
    args.subargs[0].nBackEdges = ValRange(1, 5);
    args.subargs[0].goldPct = 0.1;
    args.subargs[0].nMonstersA = ValRange(1, 2);

    boundsRight = args.region;
    boundsRight.min[axis] = pivot;
    args.subargs[1].nPitTraps = ValRange(1, 5);
    args.subargs[1].nRockTraps = ValRange(3, 10);
    args.subargs[1].goldPct = 2.0;
    args.subargs[1].nMonstersA = ValRange(3, 4);

    auto w = new World;
    auto tree1 = genTree(boundsLeft, args.subargs[0].tree);
    auto tree2 = genTree(boundsRight, args.subargs[1].tree);

    // Stitch two halves of map together
    w.map.waterLevel = args.waterLevel.pick;
    w.map.tree = new MapNode;
    w.map.tree.axis = axis;
    w.map.tree.pivot = pivot;
    w.map.tree.left = tree1;
    w.map.tree.right = tree2;
    w.map.bounds = args.region;

    // Place doorway between two halves.
    MapNode[2] candidate;
    int n;
    foreachCandidateDoor(w.map.tree, args.region,
                         (MapNode left, MapNode right, int[4] pos)
    {
        if (uniform(0, ++n) == 0)
        {
            candidate[0] = left;
            candidate[1] = right;
            doorPos = pos;
        }
        return 0;
    });
    if (n == 0)
        throw new GenCorridorsException("No viable door placement found");

    auto d = Door(axis);
    assert(doorPos[axis] == pivot-1);
    d.pos = doorPos;
    candidate[0].doors ~= d;
    candidate[1].doors ~= d;

    // Finish up level geometry
    // IMPORTANT: connecting door must be placed before this, otherwise
    // resizeRoom() may make the door inaccessible.
    genGeometry(w, tree1, boundsLeft, args.subargs[0]);
    genGeometry(w, tree2, boundsRight, args.subargs[1]);

    if (args.sinkDoor)
    {
        // Need to do this manually because genGeometry can't do cross-region
        // sinking.
        auto floorCoor = min(candidate[0].interior.max[0],
                             candidate[1].interior.max[0]);
        foreach (node; candidate[])
        {
            auto i = node.doors.countUntil(d);
            assert(i >= 0);
            node.doors[i].pos[0] = floorCoor - 1;
        }
        doorPos[0] = floorCoor - 1;
    }

    // Generate startPos in selected half of level.
    MapNode startRoom;
    switch (args.startPart)
    {
        case 0:
            startRoom = randomDryRoom(tree1, boundsLeft, w.map.waterLevel);
            break;

        case 1:
            startRoom = randomDryRoom(tree2, boundsRight, w.map.waterLevel);
            break;

        default:
            assert(0, "Invalid start index for bipartite level gen");
    }
    startPos = startRoom.randomLocation(startRoom.interior);

    // Place objects and deco
    genObjects(w, tree1, boundsLeft, args.subargs[0], startRoom);
    genObjects(w, tree2, boundsRight, args.subargs[1], startRoom);

    switch (args.portalPart)
    {
        case 0:
            genPortal(w, tree1, boundsLeft);
            break;

        case 1:
            genPortal(w, tree2, boundsRight);
            break;

        default:
            assert(0, "Invalid portal index for bipartite level gen");
    }

    return w;
}

/**
 * Generate a door + lever combo.
 */
void genDoorAndLever(World w, int[4] doorPos, MapNode leverTree,
                     Region!(int,4) leverBounds)
{
    // Actual locked door object
    auto doorTrigId = w.triggerId++;
    w.store.createObj(Pos(doorPos), Tiled(TileId.lockedDoor, -2),
                      Name("locked door"), BlocksMovement(),
                      Triggerable(doorTrigId, TriggerEffect.toggleDoor));

    // Lever for opening the door
    Pos leverPos, floorPos;
    do
    {
        leverPos = Pos(randomLocation(leverTree, leverBounds));
        floorPos = leverPos + vec(1,0,0,0);
    } while (!w.store.getAllBy!Pos(leverPos).empty ||
             !w.locationHas!BlocksMovement(floorPos));
    w.store.createObj(leverPos, Name("big lever"), Tiled(TileId.lever1),
                      Usable(UseEffect.trigger, "pull", doorTrigId),
                      Weight(10));
}

/**
 * Scratch pad function for generating various test levels.
 */
World genTestLevel()(out int[4] startPos)
{
    auto root = new MapNode;
    root.axis = 0;
    root.pivot = 3;

    root.left = new MapNode;
    root.left.interior = region(vec(1,1,1,1), vec(4,4,4,4));
    root.left.doors = [
        Door(0, [3,1,1,1]),
        Door(0, [3,3,3,3]),
    ];

    root.right = new MapNode;
    root.right.interior = region(vec(4,1,1,1), vec(9,4,4,4));
    root.right.doors = [
        Door(0, [3,1,1,1]),
        Door(0, [3,3,3,3]),
    ];

    auto w = new World;
    w.map.tree = root;
    w.map.bounds = region(vec(1,1,1,1), vec(9,4,4,4));
    w.map.waterLevel = 9;

    addLadders(w, w.map.tree, w.map.bounds);

    auto monA = createMonsterA(&w.store, Pos(8,2,2,2));
    w.store.get!Mortal(monA.id).curStats.hp = 3;

    //createMonsterC(&w.store, Pos(2,2,2,2));
    createVeg(&w.store, Pos(2,1,2,2));
    createVeg(&w.store, Pos(2,1,3,2));
    createVeg(&w.store, Pos(4,1,3,1));
    createSharpRock(&w.store, Pos(8,1,1,1));
    createRock(&w.store, Pos(8,1,1,1));
    createRock(&w.store, Pos(8,1,1,1));

    startPos = [8,1,1,1];
    return w;
}

// vim:set ai sw=4 ts=4 et:
